// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v4"
	"github.com/thanishsid/goserver/infrastructure/db"
	"sync"
)

// Ensure, that DBMock does implement db.DB.
// If this is not the case, regenerate this file with moq.
var _ db.DB = &DBMock{}

// DBMock is a mock implementation of db.DB.
//
//	func TestSomethingThatUsesDB(t *testing.T) {
//
//		// make and configure a mocked db.DB
//		mockedDB := &DBMock{
//			BeginTxFunc: func(ctx context.Context, txOpts pgx.TxOptions) (db.Transactioner, error) {
//				panic("mock out the BeginTx method")
//			},
//			CheckImageExistsFunc: func(ctx context.Context, id uuid.UUID) (bool, error) {
//				panic("mock out the CheckImageExists method")
//			},
//			CheckImageHashExistsFunc: func(ctx context.Context, fileHash []byte) (bool, error) {
//				panic("mock out the CheckImageHashExists method")
//			},
//			DeleteImageFunc: func(ctx context.Context, id uuid.UUID) error {
//				panic("mock out the DeleteImage method")
//			},
//			DeleteRoleFunc: func(ctx context.Context, id string) error {
//				panic("mock out the DeleteRole method")
//			},
//			GetAllImagesInIDSFunc: func(ctx context.Context, imageIds []uuid.UUID) ([]db.GetAllImagesInIDSRow, error) {
//				panic("mock out the GetAllImagesInIDS method")
//			},
//			GetAllRolesFunc: func(ctx context.Context) ([]db.Role, error) {
//				panic("mock out the GetAllRoles method")
//			},
//			GetAllUsersInIDSFunc: func(ctx context.Context, userIds []uuid.UUID) ([]db.GetAllUsersInIDSRow, error) {
//				panic("mock out the GetAllUsersInIDS method")
//			},
//			GetImageByIdFunc: func(ctx context.Context, id uuid.UUID) (db.Image, error) {
//				panic("mock out the GetImageById method")
//			},
//			GetManyImagesFunc: func(ctx context.Context, arg db.GetManyImagesParams) ([]db.GetManyImagesRow, error) {
//				panic("mock out the GetManyImages method")
//			},
//			GetManyUsersFunc: func(ctx context.Context, arg db.GetManyUsersParams) ([]db.GetManyUsersRow, error) {
//				panic("mock out the GetManyUsers method")
//			},
//			GetUserByEmailFunc: func(ctx context.Context, email string) (db.GetUserByEmailRow, error) {
//				panic("mock out the GetUserByEmail method")
//			},
//			GetUserByIdFunc: func(ctx context.Context, userID uuid.UUID) (db.GetUserByIdRow, error) {
//				panic("mock out the GetUserById method")
//			},
//			HardDeleteUserFunc: func(ctx context.Context, userID uuid.UUID) error {
//				panic("mock out the HardDeleteUser method")
//			},
//			InsertOrUpdateImageFunc: func(ctx context.Context, arg db.InsertOrUpdateImageParams) error {
//				panic("mock out the InsertOrUpdateImage method")
//			},
//			InsertOrUpdateRolesFunc: func(ctx context.Context, arg db.InsertOrUpdateRolesParams) error {
//				panic("mock out the InsertOrUpdateRoles method")
//			},
//			InsertOrUpdateUserFunc: func(ctx context.Context, arg db.InsertOrUpdateUserParams) error {
//				panic("mock out the InsertOrUpdateUser method")
//			},
//			SoftDeleteUserFunc: func(ctx context.Context, userID uuid.UUID) error {
//				panic("mock out the SoftDeleteUser method")
//			},
//		}
//
//		// use mockedDB in code that requires db.DB
//		// and then make assertions.
//
//	}
type DBMock struct {
	// BeginTxFunc mocks the BeginTx method.
	BeginTxFunc func(ctx context.Context, txOpts pgx.TxOptions) (db.Transactioner, error)

	// CheckImageExistsFunc mocks the CheckImageExists method.
	CheckImageExistsFunc func(ctx context.Context, id uuid.UUID) (bool, error)

	// CheckImageHashExistsFunc mocks the CheckImageHashExists method.
	CheckImageHashExistsFunc func(ctx context.Context, fileHash []byte) (bool, error)

	// DeleteImageFunc mocks the DeleteImage method.
	DeleteImageFunc func(ctx context.Context, id uuid.UUID) error

	// DeleteRoleFunc mocks the DeleteRole method.
	DeleteRoleFunc func(ctx context.Context, id string) error

	// GetAllImagesInIDSFunc mocks the GetAllImagesInIDS method.
	GetAllImagesInIDSFunc func(ctx context.Context, imageIds []uuid.UUID) ([]db.GetAllImagesInIDSRow, error)

	// GetAllRolesFunc mocks the GetAllRoles method.
	GetAllRolesFunc func(ctx context.Context) ([]db.Role, error)

	// GetAllUsersInIDSFunc mocks the GetAllUsersInIDS method.
	GetAllUsersInIDSFunc func(ctx context.Context, userIds []uuid.UUID) ([]db.GetAllUsersInIDSRow, error)

	// GetImageByIdFunc mocks the GetImageById method.
	GetImageByIdFunc func(ctx context.Context, id uuid.UUID) (db.Image, error)

	// GetManyImagesFunc mocks the GetManyImages method.
	GetManyImagesFunc func(ctx context.Context, arg db.GetManyImagesParams) ([]db.GetManyImagesRow, error)

	// GetManyUsersFunc mocks the GetManyUsers method.
	GetManyUsersFunc func(ctx context.Context, arg db.GetManyUsersParams) ([]db.GetManyUsersRow, error)

	// GetUserByEmailFunc mocks the GetUserByEmail method.
	GetUserByEmailFunc func(ctx context.Context, email string) (db.GetUserByEmailRow, error)

	// GetUserByIdFunc mocks the GetUserById method.
	GetUserByIdFunc func(ctx context.Context, userID uuid.UUID) (db.GetUserByIdRow, error)

	// HardDeleteUserFunc mocks the HardDeleteUser method.
	HardDeleteUserFunc func(ctx context.Context, userID uuid.UUID) error

	// InsertOrUpdateImageFunc mocks the InsertOrUpdateImage method.
	InsertOrUpdateImageFunc func(ctx context.Context, arg db.InsertOrUpdateImageParams) error

	// InsertOrUpdateRolesFunc mocks the InsertOrUpdateRoles method.
	InsertOrUpdateRolesFunc func(ctx context.Context, arg db.InsertOrUpdateRolesParams) error

	// InsertOrUpdateUserFunc mocks the InsertOrUpdateUser method.
	InsertOrUpdateUserFunc func(ctx context.Context, arg db.InsertOrUpdateUserParams) error

	// SoftDeleteUserFunc mocks the SoftDeleteUser method.
	SoftDeleteUserFunc func(ctx context.Context, userID uuid.UUID) error

	// calls tracks calls to the methods.
	calls struct {
		// BeginTx holds details about calls to the BeginTx method.
		BeginTx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxOpts is the txOpts argument value.
			TxOpts pgx.TxOptions
		}
		// CheckImageExists holds details about calls to the CheckImageExists method.
		CheckImageExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// CheckImageHashExists holds details about calls to the CheckImageHashExists method.
		CheckImageHashExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FileHash is the fileHash argument value.
			FileHash []byte
		}
		// DeleteImage holds details about calls to the DeleteImage method.
		DeleteImage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// DeleteRole holds details about calls to the DeleteRole method.
		DeleteRole []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetAllImagesInIDS holds details about calls to the GetAllImagesInIDS method.
		GetAllImagesInIDS []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ImageIds is the imageIds argument value.
			ImageIds []uuid.UUID
		}
		// GetAllRoles holds details about calls to the GetAllRoles method.
		GetAllRoles []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetAllUsersInIDS holds details about calls to the GetAllUsersInIDS method.
		GetAllUsersInIDS []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserIds is the userIds argument value.
			UserIds []uuid.UUID
		}
		// GetImageById holds details about calls to the GetImageById method.
		GetImageById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetManyImages holds details about calls to the GetManyImages method.
		GetManyImages []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg db.GetManyImagesParams
		}
		// GetManyUsers holds details about calls to the GetManyUsers method.
		GetManyUsers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg db.GetManyUsersParams
		}
		// GetUserByEmail holds details about calls to the GetUserByEmail method.
		GetUserByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// GetUserById holds details about calls to the GetUserById method.
		GetUserById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
		// HardDeleteUser holds details about calls to the HardDeleteUser method.
		HardDeleteUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
		// InsertOrUpdateImage holds details about calls to the InsertOrUpdateImage method.
		InsertOrUpdateImage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg db.InsertOrUpdateImageParams
		}
		// InsertOrUpdateRoles holds details about calls to the InsertOrUpdateRoles method.
		InsertOrUpdateRoles []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg db.InsertOrUpdateRolesParams
		}
		// InsertOrUpdateUser holds details about calls to the InsertOrUpdateUser method.
		InsertOrUpdateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg db.InsertOrUpdateUserParams
		}
		// SoftDeleteUser holds details about calls to the SoftDeleteUser method.
		SoftDeleteUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
	}
	lockBeginTx              sync.RWMutex
	lockCheckImageExists     sync.RWMutex
	lockCheckImageHashExists sync.RWMutex
	lockDeleteImage          sync.RWMutex
	lockDeleteRole           sync.RWMutex
	lockGetAllImagesInIDS    sync.RWMutex
	lockGetAllRoles          sync.RWMutex
	lockGetAllUsersInIDS     sync.RWMutex
	lockGetImageById         sync.RWMutex
	lockGetManyImages        sync.RWMutex
	lockGetManyUsers         sync.RWMutex
	lockGetUserByEmail       sync.RWMutex
	lockGetUserById          sync.RWMutex
	lockHardDeleteUser       sync.RWMutex
	lockInsertOrUpdateImage  sync.RWMutex
	lockInsertOrUpdateRoles  sync.RWMutex
	lockInsertOrUpdateUser   sync.RWMutex
	lockSoftDeleteUser       sync.RWMutex
}

// BeginTx calls BeginTxFunc.
func (mock *DBMock) BeginTx(ctx context.Context, txOpts pgx.TxOptions) (db.Transactioner, error) {
	if mock.BeginTxFunc == nil {
		panic("DBMock.BeginTxFunc: method is nil but DB.BeginTx was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		TxOpts pgx.TxOptions
	}{
		Ctx:    ctx,
		TxOpts: txOpts,
	}
	mock.lockBeginTx.Lock()
	mock.calls.BeginTx = append(mock.calls.BeginTx, callInfo)
	mock.lockBeginTx.Unlock()
	return mock.BeginTxFunc(ctx, txOpts)
}

// BeginTxCalls gets all the calls that were made to BeginTx.
// Check the length with:
//
//	len(mockedDB.BeginTxCalls())
func (mock *DBMock) BeginTxCalls() []struct {
	Ctx    context.Context
	TxOpts pgx.TxOptions
} {
	var calls []struct {
		Ctx    context.Context
		TxOpts pgx.TxOptions
	}
	mock.lockBeginTx.RLock()
	calls = mock.calls.BeginTx
	mock.lockBeginTx.RUnlock()
	return calls
}

// CheckImageExists calls CheckImageExistsFunc.
func (mock *DBMock) CheckImageExists(ctx context.Context, id uuid.UUID) (bool, error) {
	if mock.CheckImageExistsFunc == nil {
		panic("DBMock.CheckImageExistsFunc: method is nil but DB.CheckImageExists was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockCheckImageExists.Lock()
	mock.calls.CheckImageExists = append(mock.calls.CheckImageExists, callInfo)
	mock.lockCheckImageExists.Unlock()
	return mock.CheckImageExistsFunc(ctx, id)
}

// CheckImageExistsCalls gets all the calls that were made to CheckImageExists.
// Check the length with:
//
//	len(mockedDB.CheckImageExistsCalls())
func (mock *DBMock) CheckImageExistsCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockCheckImageExists.RLock()
	calls = mock.calls.CheckImageExists
	mock.lockCheckImageExists.RUnlock()
	return calls
}

// CheckImageHashExists calls CheckImageHashExistsFunc.
func (mock *DBMock) CheckImageHashExists(ctx context.Context, fileHash []byte) (bool, error) {
	if mock.CheckImageHashExistsFunc == nil {
		panic("DBMock.CheckImageHashExistsFunc: method is nil but DB.CheckImageHashExists was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		FileHash []byte
	}{
		Ctx:      ctx,
		FileHash: fileHash,
	}
	mock.lockCheckImageHashExists.Lock()
	mock.calls.CheckImageHashExists = append(mock.calls.CheckImageHashExists, callInfo)
	mock.lockCheckImageHashExists.Unlock()
	return mock.CheckImageHashExistsFunc(ctx, fileHash)
}

// CheckImageHashExistsCalls gets all the calls that were made to CheckImageHashExists.
// Check the length with:
//
//	len(mockedDB.CheckImageHashExistsCalls())
func (mock *DBMock) CheckImageHashExistsCalls() []struct {
	Ctx      context.Context
	FileHash []byte
} {
	var calls []struct {
		Ctx      context.Context
		FileHash []byte
	}
	mock.lockCheckImageHashExists.RLock()
	calls = mock.calls.CheckImageHashExists
	mock.lockCheckImageHashExists.RUnlock()
	return calls
}

// DeleteImage calls DeleteImageFunc.
func (mock *DBMock) DeleteImage(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteImageFunc == nil {
		panic("DBMock.DeleteImageFunc: method is nil but DB.DeleteImage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteImage.Lock()
	mock.calls.DeleteImage = append(mock.calls.DeleteImage, callInfo)
	mock.lockDeleteImage.Unlock()
	return mock.DeleteImageFunc(ctx, id)
}

// DeleteImageCalls gets all the calls that were made to DeleteImage.
// Check the length with:
//
//	len(mockedDB.DeleteImageCalls())
func (mock *DBMock) DeleteImageCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDeleteImage.RLock()
	calls = mock.calls.DeleteImage
	mock.lockDeleteImage.RUnlock()
	return calls
}

// DeleteRole calls DeleteRoleFunc.
func (mock *DBMock) DeleteRole(ctx context.Context, id string) error {
	if mock.DeleteRoleFunc == nil {
		panic("DBMock.DeleteRoleFunc: method is nil but DB.DeleteRole was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteRole.Lock()
	mock.calls.DeleteRole = append(mock.calls.DeleteRole, callInfo)
	mock.lockDeleteRole.Unlock()
	return mock.DeleteRoleFunc(ctx, id)
}

// DeleteRoleCalls gets all the calls that were made to DeleteRole.
// Check the length with:
//
//	len(mockedDB.DeleteRoleCalls())
func (mock *DBMock) DeleteRoleCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockDeleteRole.RLock()
	calls = mock.calls.DeleteRole
	mock.lockDeleteRole.RUnlock()
	return calls
}

// GetAllImagesInIDS calls GetAllImagesInIDSFunc.
func (mock *DBMock) GetAllImagesInIDS(ctx context.Context, imageIds []uuid.UUID) ([]db.GetAllImagesInIDSRow, error) {
	if mock.GetAllImagesInIDSFunc == nil {
		panic("DBMock.GetAllImagesInIDSFunc: method is nil but DB.GetAllImagesInIDS was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		ImageIds []uuid.UUID
	}{
		Ctx:      ctx,
		ImageIds: imageIds,
	}
	mock.lockGetAllImagesInIDS.Lock()
	mock.calls.GetAllImagesInIDS = append(mock.calls.GetAllImagesInIDS, callInfo)
	mock.lockGetAllImagesInIDS.Unlock()
	return mock.GetAllImagesInIDSFunc(ctx, imageIds)
}

// GetAllImagesInIDSCalls gets all the calls that were made to GetAllImagesInIDS.
// Check the length with:
//
//	len(mockedDB.GetAllImagesInIDSCalls())
func (mock *DBMock) GetAllImagesInIDSCalls() []struct {
	Ctx      context.Context
	ImageIds []uuid.UUID
} {
	var calls []struct {
		Ctx      context.Context
		ImageIds []uuid.UUID
	}
	mock.lockGetAllImagesInIDS.RLock()
	calls = mock.calls.GetAllImagesInIDS
	mock.lockGetAllImagesInIDS.RUnlock()
	return calls
}

// GetAllRoles calls GetAllRolesFunc.
func (mock *DBMock) GetAllRoles(ctx context.Context) ([]db.Role, error) {
	if mock.GetAllRolesFunc == nil {
		panic("DBMock.GetAllRolesFunc: method is nil but DB.GetAllRoles was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllRoles.Lock()
	mock.calls.GetAllRoles = append(mock.calls.GetAllRoles, callInfo)
	mock.lockGetAllRoles.Unlock()
	return mock.GetAllRolesFunc(ctx)
}

// GetAllRolesCalls gets all the calls that were made to GetAllRoles.
// Check the length with:
//
//	len(mockedDB.GetAllRolesCalls())
func (mock *DBMock) GetAllRolesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAllRoles.RLock()
	calls = mock.calls.GetAllRoles
	mock.lockGetAllRoles.RUnlock()
	return calls
}

// GetAllUsersInIDS calls GetAllUsersInIDSFunc.
func (mock *DBMock) GetAllUsersInIDS(ctx context.Context, userIds []uuid.UUID) ([]db.GetAllUsersInIDSRow, error) {
	if mock.GetAllUsersInIDSFunc == nil {
		panic("DBMock.GetAllUsersInIDSFunc: method is nil but DB.GetAllUsersInIDS was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		UserIds []uuid.UUID
	}{
		Ctx:     ctx,
		UserIds: userIds,
	}
	mock.lockGetAllUsersInIDS.Lock()
	mock.calls.GetAllUsersInIDS = append(mock.calls.GetAllUsersInIDS, callInfo)
	mock.lockGetAllUsersInIDS.Unlock()
	return mock.GetAllUsersInIDSFunc(ctx, userIds)
}

// GetAllUsersInIDSCalls gets all the calls that were made to GetAllUsersInIDS.
// Check the length with:
//
//	len(mockedDB.GetAllUsersInIDSCalls())
func (mock *DBMock) GetAllUsersInIDSCalls() []struct {
	Ctx     context.Context
	UserIds []uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		UserIds []uuid.UUID
	}
	mock.lockGetAllUsersInIDS.RLock()
	calls = mock.calls.GetAllUsersInIDS
	mock.lockGetAllUsersInIDS.RUnlock()
	return calls
}

// GetImageById calls GetImageByIdFunc.
func (mock *DBMock) GetImageById(ctx context.Context, id uuid.UUID) (db.Image, error) {
	if mock.GetImageByIdFunc == nil {
		panic("DBMock.GetImageByIdFunc: method is nil but DB.GetImageById was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetImageById.Lock()
	mock.calls.GetImageById = append(mock.calls.GetImageById, callInfo)
	mock.lockGetImageById.Unlock()
	return mock.GetImageByIdFunc(ctx, id)
}

// GetImageByIdCalls gets all the calls that were made to GetImageById.
// Check the length with:
//
//	len(mockedDB.GetImageByIdCalls())
func (mock *DBMock) GetImageByIdCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetImageById.RLock()
	calls = mock.calls.GetImageById
	mock.lockGetImageById.RUnlock()
	return calls
}

// GetManyImages calls GetManyImagesFunc.
func (mock *DBMock) GetManyImages(ctx context.Context, arg db.GetManyImagesParams) ([]db.GetManyImagesRow, error) {
	if mock.GetManyImagesFunc == nil {
		panic("DBMock.GetManyImagesFunc: method is nil but DB.GetManyImages was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg db.GetManyImagesParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockGetManyImages.Lock()
	mock.calls.GetManyImages = append(mock.calls.GetManyImages, callInfo)
	mock.lockGetManyImages.Unlock()
	return mock.GetManyImagesFunc(ctx, arg)
}

// GetManyImagesCalls gets all the calls that were made to GetManyImages.
// Check the length with:
//
//	len(mockedDB.GetManyImagesCalls())
func (mock *DBMock) GetManyImagesCalls() []struct {
	Ctx context.Context
	Arg db.GetManyImagesParams
} {
	var calls []struct {
		Ctx context.Context
		Arg db.GetManyImagesParams
	}
	mock.lockGetManyImages.RLock()
	calls = mock.calls.GetManyImages
	mock.lockGetManyImages.RUnlock()
	return calls
}

// GetManyUsers calls GetManyUsersFunc.
func (mock *DBMock) GetManyUsers(ctx context.Context, arg db.GetManyUsersParams) ([]db.GetManyUsersRow, error) {
	if mock.GetManyUsersFunc == nil {
		panic("DBMock.GetManyUsersFunc: method is nil but DB.GetManyUsers was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg db.GetManyUsersParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockGetManyUsers.Lock()
	mock.calls.GetManyUsers = append(mock.calls.GetManyUsers, callInfo)
	mock.lockGetManyUsers.Unlock()
	return mock.GetManyUsersFunc(ctx, arg)
}

// GetManyUsersCalls gets all the calls that were made to GetManyUsers.
// Check the length with:
//
//	len(mockedDB.GetManyUsersCalls())
func (mock *DBMock) GetManyUsersCalls() []struct {
	Ctx context.Context
	Arg db.GetManyUsersParams
} {
	var calls []struct {
		Ctx context.Context
		Arg db.GetManyUsersParams
	}
	mock.lockGetManyUsers.RLock()
	calls = mock.calls.GetManyUsers
	mock.lockGetManyUsers.RUnlock()
	return calls
}

// GetUserByEmail calls GetUserByEmailFunc.
func (mock *DBMock) GetUserByEmail(ctx context.Context, email string) (db.GetUserByEmailRow, error) {
	if mock.GetUserByEmailFunc == nil {
		panic("DBMock.GetUserByEmailFunc: method is nil but DB.GetUserByEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockGetUserByEmail.Lock()
	mock.calls.GetUserByEmail = append(mock.calls.GetUserByEmail, callInfo)
	mock.lockGetUserByEmail.Unlock()
	return mock.GetUserByEmailFunc(ctx, email)
}

// GetUserByEmailCalls gets all the calls that were made to GetUserByEmail.
// Check the length with:
//
//	len(mockedDB.GetUserByEmailCalls())
func (mock *DBMock) GetUserByEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockGetUserByEmail.RLock()
	calls = mock.calls.GetUserByEmail
	mock.lockGetUserByEmail.RUnlock()
	return calls
}

// GetUserById calls GetUserByIdFunc.
func (mock *DBMock) GetUserById(ctx context.Context, userID uuid.UUID) (db.GetUserByIdRow, error) {
	if mock.GetUserByIdFunc == nil {
		panic("DBMock.GetUserByIdFunc: method is nil but DB.GetUserById was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockGetUserById.Lock()
	mock.calls.GetUserById = append(mock.calls.GetUserById, callInfo)
	mock.lockGetUserById.Unlock()
	return mock.GetUserByIdFunc(ctx, userID)
}

// GetUserByIdCalls gets all the calls that were made to GetUserById.
// Check the length with:
//
//	len(mockedDB.GetUserByIdCalls())
func (mock *DBMock) GetUserByIdCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockGetUserById.RLock()
	calls = mock.calls.GetUserById
	mock.lockGetUserById.RUnlock()
	return calls
}

// HardDeleteUser calls HardDeleteUserFunc.
func (mock *DBMock) HardDeleteUser(ctx context.Context, userID uuid.UUID) error {
	if mock.HardDeleteUserFunc == nil {
		panic("DBMock.HardDeleteUserFunc: method is nil but DB.HardDeleteUser was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockHardDeleteUser.Lock()
	mock.calls.HardDeleteUser = append(mock.calls.HardDeleteUser, callInfo)
	mock.lockHardDeleteUser.Unlock()
	return mock.HardDeleteUserFunc(ctx, userID)
}

// HardDeleteUserCalls gets all the calls that were made to HardDeleteUser.
// Check the length with:
//
//	len(mockedDB.HardDeleteUserCalls())
func (mock *DBMock) HardDeleteUserCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockHardDeleteUser.RLock()
	calls = mock.calls.HardDeleteUser
	mock.lockHardDeleteUser.RUnlock()
	return calls
}

// InsertOrUpdateImage calls InsertOrUpdateImageFunc.
func (mock *DBMock) InsertOrUpdateImage(ctx context.Context, arg db.InsertOrUpdateImageParams) error {
	if mock.InsertOrUpdateImageFunc == nil {
		panic("DBMock.InsertOrUpdateImageFunc: method is nil but DB.InsertOrUpdateImage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg db.InsertOrUpdateImageParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertOrUpdateImage.Lock()
	mock.calls.InsertOrUpdateImage = append(mock.calls.InsertOrUpdateImage, callInfo)
	mock.lockInsertOrUpdateImage.Unlock()
	return mock.InsertOrUpdateImageFunc(ctx, arg)
}

// InsertOrUpdateImageCalls gets all the calls that were made to InsertOrUpdateImage.
// Check the length with:
//
//	len(mockedDB.InsertOrUpdateImageCalls())
func (mock *DBMock) InsertOrUpdateImageCalls() []struct {
	Ctx context.Context
	Arg db.InsertOrUpdateImageParams
} {
	var calls []struct {
		Ctx context.Context
		Arg db.InsertOrUpdateImageParams
	}
	mock.lockInsertOrUpdateImage.RLock()
	calls = mock.calls.InsertOrUpdateImage
	mock.lockInsertOrUpdateImage.RUnlock()
	return calls
}

// InsertOrUpdateRoles calls InsertOrUpdateRolesFunc.
func (mock *DBMock) InsertOrUpdateRoles(ctx context.Context, arg db.InsertOrUpdateRolesParams) error {
	if mock.InsertOrUpdateRolesFunc == nil {
		panic("DBMock.InsertOrUpdateRolesFunc: method is nil but DB.InsertOrUpdateRoles was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg db.InsertOrUpdateRolesParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertOrUpdateRoles.Lock()
	mock.calls.InsertOrUpdateRoles = append(mock.calls.InsertOrUpdateRoles, callInfo)
	mock.lockInsertOrUpdateRoles.Unlock()
	return mock.InsertOrUpdateRolesFunc(ctx, arg)
}

// InsertOrUpdateRolesCalls gets all the calls that were made to InsertOrUpdateRoles.
// Check the length with:
//
//	len(mockedDB.InsertOrUpdateRolesCalls())
func (mock *DBMock) InsertOrUpdateRolesCalls() []struct {
	Ctx context.Context
	Arg db.InsertOrUpdateRolesParams
} {
	var calls []struct {
		Ctx context.Context
		Arg db.InsertOrUpdateRolesParams
	}
	mock.lockInsertOrUpdateRoles.RLock()
	calls = mock.calls.InsertOrUpdateRoles
	mock.lockInsertOrUpdateRoles.RUnlock()
	return calls
}

// InsertOrUpdateUser calls InsertOrUpdateUserFunc.
func (mock *DBMock) InsertOrUpdateUser(ctx context.Context, arg db.InsertOrUpdateUserParams) error {
	if mock.InsertOrUpdateUserFunc == nil {
		panic("DBMock.InsertOrUpdateUserFunc: method is nil but DB.InsertOrUpdateUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg db.InsertOrUpdateUserParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertOrUpdateUser.Lock()
	mock.calls.InsertOrUpdateUser = append(mock.calls.InsertOrUpdateUser, callInfo)
	mock.lockInsertOrUpdateUser.Unlock()
	return mock.InsertOrUpdateUserFunc(ctx, arg)
}

// InsertOrUpdateUserCalls gets all the calls that were made to InsertOrUpdateUser.
// Check the length with:
//
//	len(mockedDB.InsertOrUpdateUserCalls())
func (mock *DBMock) InsertOrUpdateUserCalls() []struct {
	Ctx context.Context
	Arg db.InsertOrUpdateUserParams
} {
	var calls []struct {
		Ctx context.Context
		Arg db.InsertOrUpdateUserParams
	}
	mock.lockInsertOrUpdateUser.RLock()
	calls = mock.calls.InsertOrUpdateUser
	mock.lockInsertOrUpdateUser.RUnlock()
	return calls
}

// SoftDeleteUser calls SoftDeleteUserFunc.
func (mock *DBMock) SoftDeleteUser(ctx context.Context, userID uuid.UUID) error {
	if mock.SoftDeleteUserFunc == nil {
		panic("DBMock.SoftDeleteUserFunc: method is nil but DB.SoftDeleteUser was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockSoftDeleteUser.Lock()
	mock.calls.SoftDeleteUser = append(mock.calls.SoftDeleteUser, callInfo)
	mock.lockSoftDeleteUser.Unlock()
	return mock.SoftDeleteUserFunc(ctx, userID)
}

// SoftDeleteUserCalls gets all the calls that were made to SoftDeleteUser.
// Check the length with:
//
//	len(mockedDB.SoftDeleteUserCalls())
func (mock *DBMock) SoftDeleteUserCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockSoftDeleteUser.RLock()
	calls = mock.calls.SoftDeleteUser
	mock.lockSoftDeleteUser.RUnlock()
	return calls
}

// Ensure, that QuerierMock does implement db.Querier.
// If this is not the case, regenerate this file with moq.
var _ db.Querier = &QuerierMock{}

// QuerierMock is a mock implementation of db.Querier.
//
//	func TestSomethingThatUsesQuerier(t *testing.T) {
//
//		// make and configure a mocked db.Querier
//		mockedQuerier := &QuerierMock{
//			CheckImageExistsFunc: func(ctx context.Context, id uuid.UUID) (bool, error) {
//				panic("mock out the CheckImageExists method")
//			},
//			CheckImageHashExistsFunc: func(ctx context.Context, fileHash []byte) (bool, error) {
//				panic("mock out the CheckImageHashExists method")
//			},
//			DeleteImageFunc: func(ctx context.Context, id uuid.UUID) error {
//				panic("mock out the DeleteImage method")
//			},
//			DeleteRoleFunc: func(ctx context.Context, id string) error {
//				panic("mock out the DeleteRole method")
//			},
//			GetAllImagesInIDSFunc: func(ctx context.Context, imageIds []uuid.UUID) ([]db.GetAllImagesInIDSRow, error) {
//				panic("mock out the GetAllImagesInIDS method")
//			},
//			GetAllRolesFunc: func(ctx context.Context) ([]db.Role, error) {
//				panic("mock out the GetAllRoles method")
//			},
//			GetAllUsersInIDSFunc: func(ctx context.Context, userIds []uuid.UUID) ([]db.GetAllUsersInIDSRow, error) {
//				panic("mock out the GetAllUsersInIDS method")
//			},
//			GetImageByIdFunc: func(ctx context.Context, id uuid.UUID) (db.Image, error) {
//				panic("mock out the GetImageById method")
//			},
//			GetManyImagesFunc: func(ctx context.Context, arg db.GetManyImagesParams) ([]db.GetManyImagesRow, error) {
//				panic("mock out the GetManyImages method")
//			},
//			GetManyUsersFunc: func(ctx context.Context, arg db.GetManyUsersParams) ([]db.GetManyUsersRow, error) {
//				panic("mock out the GetManyUsers method")
//			},
//			GetUserByEmailFunc: func(ctx context.Context, email string) (db.GetUserByEmailRow, error) {
//				panic("mock out the GetUserByEmail method")
//			},
//			GetUserByIdFunc: func(ctx context.Context, userID uuid.UUID) (db.GetUserByIdRow, error) {
//				panic("mock out the GetUserById method")
//			},
//			HardDeleteUserFunc: func(ctx context.Context, userID uuid.UUID) error {
//				panic("mock out the HardDeleteUser method")
//			},
//			InsertOrUpdateImageFunc: func(ctx context.Context, arg db.InsertOrUpdateImageParams) error {
//				panic("mock out the InsertOrUpdateImage method")
//			},
//			InsertOrUpdateRolesFunc: func(ctx context.Context, arg db.InsertOrUpdateRolesParams) error {
//				panic("mock out the InsertOrUpdateRoles method")
//			},
//			InsertOrUpdateUserFunc: func(ctx context.Context, arg db.InsertOrUpdateUserParams) error {
//				panic("mock out the InsertOrUpdateUser method")
//			},
//			SoftDeleteUserFunc: func(ctx context.Context, userID uuid.UUID) error {
//				panic("mock out the SoftDeleteUser method")
//			},
//		}
//
//		// use mockedQuerier in code that requires db.Querier
//		// and then make assertions.
//
//	}
type QuerierMock struct {
	// CheckImageExistsFunc mocks the CheckImageExists method.
	CheckImageExistsFunc func(ctx context.Context, id uuid.UUID) (bool, error)

	// CheckImageHashExistsFunc mocks the CheckImageHashExists method.
	CheckImageHashExistsFunc func(ctx context.Context, fileHash []byte) (bool, error)

	// DeleteImageFunc mocks the DeleteImage method.
	DeleteImageFunc func(ctx context.Context, id uuid.UUID) error

	// DeleteRoleFunc mocks the DeleteRole method.
	DeleteRoleFunc func(ctx context.Context, id string) error

	// GetAllImagesInIDSFunc mocks the GetAllImagesInIDS method.
	GetAllImagesInIDSFunc func(ctx context.Context, imageIds []uuid.UUID) ([]db.GetAllImagesInIDSRow, error)

	// GetAllRolesFunc mocks the GetAllRoles method.
	GetAllRolesFunc func(ctx context.Context) ([]db.Role, error)

	// GetAllUsersInIDSFunc mocks the GetAllUsersInIDS method.
	GetAllUsersInIDSFunc func(ctx context.Context, userIds []uuid.UUID) ([]db.GetAllUsersInIDSRow, error)

	// GetImageByIdFunc mocks the GetImageById method.
	GetImageByIdFunc func(ctx context.Context, id uuid.UUID) (db.Image, error)

	// GetManyImagesFunc mocks the GetManyImages method.
	GetManyImagesFunc func(ctx context.Context, arg db.GetManyImagesParams) ([]db.GetManyImagesRow, error)

	// GetManyUsersFunc mocks the GetManyUsers method.
	GetManyUsersFunc func(ctx context.Context, arg db.GetManyUsersParams) ([]db.GetManyUsersRow, error)

	// GetUserByEmailFunc mocks the GetUserByEmail method.
	GetUserByEmailFunc func(ctx context.Context, email string) (db.GetUserByEmailRow, error)

	// GetUserByIdFunc mocks the GetUserById method.
	GetUserByIdFunc func(ctx context.Context, userID uuid.UUID) (db.GetUserByIdRow, error)

	// HardDeleteUserFunc mocks the HardDeleteUser method.
	HardDeleteUserFunc func(ctx context.Context, userID uuid.UUID) error

	// InsertOrUpdateImageFunc mocks the InsertOrUpdateImage method.
	InsertOrUpdateImageFunc func(ctx context.Context, arg db.InsertOrUpdateImageParams) error

	// InsertOrUpdateRolesFunc mocks the InsertOrUpdateRoles method.
	InsertOrUpdateRolesFunc func(ctx context.Context, arg db.InsertOrUpdateRolesParams) error

	// InsertOrUpdateUserFunc mocks the InsertOrUpdateUser method.
	InsertOrUpdateUserFunc func(ctx context.Context, arg db.InsertOrUpdateUserParams) error

	// SoftDeleteUserFunc mocks the SoftDeleteUser method.
	SoftDeleteUserFunc func(ctx context.Context, userID uuid.UUID) error

	// calls tracks calls to the methods.
	calls struct {
		// CheckImageExists holds details about calls to the CheckImageExists method.
		CheckImageExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// CheckImageHashExists holds details about calls to the CheckImageHashExists method.
		CheckImageHashExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FileHash is the fileHash argument value.
			FileHash []byte
		}
		// DeleteImage holds details about calls to the DeleteImage method.
		DeleteImage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// DeleteRole holds details about calls to the DeleteRole method.
		DeleteRole []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetAllImagesInIDS holds details about calls to the GetAllImagesInIDS method.
		GetAllImagesInIDS []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ImageIds is the imageIds argument value.
			ImageIds []uuid.UUID
		}
		// GetAllRoles holds details about calls to the GetAllRoles method.
		GetAllRoles []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetAllUsersInIDS holds details about calls to the GetAllUsersInIDS method.
		GetAllUsersInIDS []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserIds is the userIds argument value.
			UserIds []uuid.UUID
		}
		// GetImageById holds details about calls to the GetImageById method.
		GetImageById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetManyImages holds details about calls to the GetManyImages method.
		GetManyImages []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg db.GetManyImagesParams
		}
		// GetManyUsers holds details about calls to the GetManyUsers method.
		GetManyUsers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg db.GetManyUsersParams
		}
		// GetUserByEmail holds details about calls to the GetUserByEmail method.
		GetUserByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// GetUserById holds details about calls to the GetUserById method.
		GetUserById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
		// HardDeleteUser holds details about calls to the HardDeleteUser method.
		HardDeleteUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
		// InsertOrUpdateImage holds details about calls to the InsertOrUpdateImage method.
		InsertOrUpdateImage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg db.InsertOrUpdateImageParams
		}
		// InsertOrUpdateRoles holds details about calls to the InsertOrUpdateRoles method.
		InsertOrUpdateRoles []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg db.InsertOrUpdateRolesParams
		}
		// InsertOrUpdateUser holds details about calls to the InsertOrUpdateUser method.
		InsertOrUpdateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg db.InsertOrUpdateUserParams
		}
		// SoftDeleteUser holds details about calls to the SoftDeleteUser method.
		SoftDeleteUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
	}
	lockCheckImageExists     sync.RWMutex
	lockCheckImageHashExists sync.RWMutex
	lockDeleteImage          sync.RWMutex
	lockDeleteRole           sync.RWMutex
	lockGetAllImagesInIDS    sync.RWMutex
	lockGetAllRoles          sync.RWMutex
	lockGetAllUsersInIDS     sync.RWMutex
	lockGetImageById         sync.RWMutex
	lockGetManyImages        sync.RWMutex
	lockGetManyUsers         sync.RWMutex
	lockGetUserByEmail       sync.RWMutex
	lockGetUserById          sync.RWMutex
	lockHardDeleteUser       sync.RWMutex
	lockInsertOrUpdateImage  sync.RWMutex
	lockInsertOrUpdateRoles  sync.RWMutex
	lockInsertOrUpdateUser   sync.RWMutex
	lockSoftDeleteUser       sync.RWMutex
}

// CheckImageExists calls CheckImageExistsFunc.
func (mock *QuerierMock) CheckImageExists(ctx context.Context, id uuid.UUID) (bool, error) {
	if mock.CheckImageExistsFunc == nil {
		panic("QuerierMock.CheckImageExistsFunc: method is nil but Querier.CheckImageExists was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockCheckImageExists.Lock()
	mock.calls.CheckImageExists = append(mock.calls.CheckImageExists, callInfo)
	mock.lockCheckImageExists.Unlock()
	return mock.CheckImageExistsFunc(ctx, id)
}

// CheckImageExistsCalls gets all the calls that were made to CheckImageExists.
// Check the length with:
//
//	len(mockedQuerier.CheckImageExistsCalls())
func (mock *QuerierMock) CheckImageExistsCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockCheckImageExists.RLock()
	calls = mock.calls.CheckImageExists
	mock.lockCheckImageExists.RUnlock()
	return calls
}

// CheckImageHashExists calls CheckImageHashExistsFunc.
func (mock *QuerierMock) CheckImageHashExists(ctx context.Context, fileHash []byte) (bool, error) {
	if mock.CheckImageHashExistsFunc == nil {
		panic("QuerierMock.CheckImageHashExistsFunc: method is nil but Querier.CheckImageHashExists was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		FileHash []byte
	}{
		Ctx:      ctx,
		FileHash: fileHash,
	}
	mock.lockCheckImageHashExists.Lock()
	mock.calls.CheckImageHashExists = append(mock.calls.CheckImageHashExists, callInfo)
	mock.lockCheckImageHashExists.Unlock()
	return mock.CheckImageHashExistsFunc(ctx, fileHash)
}

// CheckImageHashExistsCalls gets all the calls that were made to CheckImageHashExists.
// Check the length with:
//
//	len(mockedQuerier.CheckImageHashExistsCalls())
func (mock *QuerierMock) CheckImageHashExistsCalls() []struct {
	Ctx      context.Context
	FileHash []byte
} {
	var calls []struct {
		Ctx      context.Context
		FileHash []byte
	}
	mock.lockCheckImageHashExists.RLock()
	calls = mock.calls.CheckImageHashExists
	mock.lockCheckImageHashExists.RUnlock()
	return calls
}

// DeleteImage calls DeleteImageFunc.
func (mock *QuerierMock) DeleteImage(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteImageFunc == nil {
		panic("QuerierMock.DeleteImageFunc: method is nil but Querier.DeleteImage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteImage.Lock()
	mock.calls.DeleteImage = append(mock.calls.DeleteImage, callInfo)
	mock.lockDeleteImage.Unlock()
	return mock.DeleteImageFunc(ctx, id)
}

// DeleteImageCalls gets all the calls that were made to DeleteImage.
// Check the length with:
//
//	len(mockedQuerier.DeleteImageCalls())
func (mock *QuerierMock) DeleteImageCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDeleteImage.RLock()
	calls = mock.calls.DeleteImage
	mock.lockDeleteImage.RUnlock()
	return calls
}

// DeleteRole calls DeleteRoleFunc.
func (mock *QuerierMock) DeleteRole(ctx context.Context, id string) error {
	if mock.DeleteRoleFunc == nil {
		panic("QuerierMock.DeleteRoleFunc: method is nil but Querier.DeleteRole was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteRole.Lock()
	mock.calls.DeleteRole = append(mock.calls.DeleteRole, callInfo)
	mock.lockDeleteRole.Unlock()
	return mock.DeleteRoleFunc(ctx, id)
}

// DeleteRoleCalls gets all the calls that were made to DeleteRole.
// Check the length with:
//
//	len(mockedQuerier.DeleteRoleCalls())
func (mock *QuerierMock) DeleteRoleCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockDeleteRole.RLock()
	calls = mock.calls.DeleteRole
	mock.lockDeleteRole.RUnlock()
	return calls
}

// GetAllImagesInIDS calls GetAllImagesInIDSFunc.
func (mock *QuerierMock) GetAllImagesInIDS(ctx context.Context, imageIds []uuid.UUID) ([]db.GetAllImagesInIDSRow, error) {
	if mock.GetAllImagesInIDSFunc == nil {
		panic("QuerierMock.GetAllImagesInIDSFunc: method is nil but Querier.GetAllImagesInIDS was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		ImageIds []uuid.UUID
	}{
		Ctx:      ctx,
		ImageIds: imageIds,
	}
	mock.lockGetAllImagesInIDS.Lock()
	mock.calls.GetAllImagesInIDS = append(mock.calls.GetAllImagesInIDS, callInfo)
	mock.lockGetAllImagesInIDS.Unlock()
	return mock.GetAllImagesInIDSFunc(ctx, imageIds)
}

// GetAllImagesInIDSCalls gets all the calls that were made to GetAllImagesInIDS.
// Check the length with:
//
//	len(mockedQuerier.GetAllImagesInIDSCalls())
func (mock *QuerierMock) GetAllImagesInIDSCalls() []struct {
	Ctx      context.Context
	ImageIds []uuid.UUID
} {
	var calls []struct {
		Ctx      context.Context
		ImageIds []uuid.UUID
	}
	mock.lockGetAllImagesInIDS.RLock()
	calls = mock.calls.GetAllImagesInIDS
	mock.lockGetAllImagesInIDS.RUnlock()
	return calls
}

// GetAllRoles calls GetAllRolesFunc.
func (mock *QuerierMock) GetAllRoles(ctx context.Context) ([]db.Role, error) {
	if mock.GetAllRolesFunc == nil {
		panic("QuerierMock.GetAllRolesFunc: method is nil but Querier.GetAllRoles was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllRoles.Lock()
	mock.calls.GetAllRoles = append(mock.calls.GetAllRoles, callInfo)
	mock.lockGetAllRoles.Unlock()
	return mock.GetAllRolesFunc(ctx)
}

// GetAllRolesCalls gets all the calls that were made to GetAllRoles.
// Check the length with:
//
//	len(mockedQuerier.GetAllRolesCalls())
func (mock *QuerierMock) GetAllRolesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAllRoles.RLock()
	calls = mock.calls.GetAllRoles
	mock.lockGetAllRoles.RUnlock()
	return calls
}

// GetAllUsersInIDS calls GetAllUsersInIDSFunc.
func (mock *QuerierMock) GetAllUsersInIDS(ctx context.Context, userIds []uuid.UUID) ([]db.GetAllUsersInIDSRow, error) {
	if mock.GetAllUsersInIDSFunc == nil {
		panic("QuerierMock.GetAllUsersInIDSFunc: method is nil but Querier.GetAllUsersInIDS was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		UserIds []uuid.UUID
	}{
		Ctx:     ctx,
		UserIds: userIds,
	}
	mock.lockGetAllUsersInIDS.Lock()
	mock.calls.GetAllUsersInIDS = append(mock.calls.GetAllUsersInIDS, callInfo)
	mock.lockGetAllUsersInIDS.Unlock()
	return mock.GetAllUsersInIDSFunc(ctx, userIds)
}

// GetAllUsersInIDSCalls gets all the calls that were made to GetAllUsersInIDS.
// Check the length with:
//
//	len(mockedQuerier.GetAllUsersInIDSCalls())
func (mock *QuerierMock) GetAllUsersInIDSCalls() []struct {
	Ctx     context.Context
	UserIds []uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		UserIds []uuid.UUID
	}
	mock.lockGetAllUsersInIDS.RLock()
	calls = mock.calls.GetAllUsersInIDS
	mock.lockGetAllUsersInIDS.RUnlock()
	return calls
}

// GetImageById calls GetImageByIdFunc.
func (mock *QuerierMock) GetImageById(ctx context.Context, id uuid.UUID) (db.Image, error) {
	if mock.GetImageByIdFunc == nil {
		panic("QuerierMock.GetImageByIdFunc: method is nil but Querier.GetImageById was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetImageById.Lock()
	mock.calls.GetImageById = append(mock.calls.GetImageById, callInfo)
	mock.lockGetImageById.Unlock()
	return mock.GetImageByIdFunc(ctx, id)
}

// GetImageByIdCalls gets all the calls that were made to GetImageById.
// Check the length with:
//
//	len(mockedQuerier.GetImageByIdCalls())
func (mock *QuerierMock) GetImageByIdCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetImageById.RLock()
	calls = mock.calls.GetImageById
	mock.lockGetImageById.RUnlock()
	return calls
}

// GetManyImages calls GetManyImagesFunc.
func (mock *QuerierMock) GetManyImages(ctx context.Context, arg db.GetManyImagesParams) ([]db.GetManyImagesRow, error) {
	if mock.GetManyImagesFunc == nil {
		panic("QuerierMock.GetManyImagesFunc: method is nil but Querier.GetManyImages was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg db.GetManyImagesParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockGetManyImages.Lock()
	mock.calls.GetManyImages = append(mock.calls.GetManyImages, callInfo)
	mock.lockGetManyImages.Unlock()
	return mock.GetManyImagesFunc(ctx, arg)
}

// GetManyImagesCalls gets all the calls that were made to GetManyImages.
// Check the length with:
//
//	len(mockedQuerier.GetManyImagesCalls())
func (mock *QuerierMock) GetManyImagesCalls() []struct {
	Ctx context.Context
	Arg db.GetManyImagesParams
} {
	var calls []struct {
		Ctx context.Context
		Arg db.GetManyImagesParams
	}
	mock.lockGetManyImages.RLock()
	calls = mock.calls.GetManyImages
	mock.lockGetManyImages.RUnlock()
	return calls
}

// GetManyUsers calls GetManyUsersFunc.
func (mock *QuerierMock) GetManyUsers(ctx context.Context, arg db.GetManyUsersParams) ([]db.GetManyUsersRow, error) {
	if mock.GetManyUsersFunc == nil {
		panic("QuerierMock.GetManyUsersFunc: method is nil but Querier.GetManyUsers was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg db.GetManyUsersParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockGetManyUsers.Lock()
	mock.calls.GetManyUsers = append(mock.calls.GetManyUsers, callInfo)
	mock.lockGetManyUsers.Unlock()
	return mock.GetManyUsersFunc(ctx, arg)
}

// GetManyUsersCalls gets all the calls that were made to GetManyUsers.
// Check the length with:
//
//	len(mockedQuerier.GetManyUsersCalls())
func (mock *QuerierMock) GetManyUsersCalls() []struct {
	Ctx context.Context
	Arg db.GetManyUsersParams
} {
	var calls []struct {
		Ctx context.Context
		Arg db.GetManyUsersParams
	}
	mock.lockGetManyUsers.RLock()
	calls = mock.calls.GetManyUsers
	mock.lockGetManyUsers.RUnlock()
	return calls
}

// GetUserByEmail calls GetUserByEmailFunc.
func (mock *QuerierMock) GetUserByEmail(ctx context.Context, email string) (db.GetUserByEmailRow, error) {
	if mock.GetUserByEmailFunc == nil {
		panic("QuerierMock.GetUserByEmailFunc: method is nil but Querier.GetUserByEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockGetUserByEmail.Lock()
	mock.calls.GetUserByEmail = append(mock.calls.GetUserByEmail, callInfo)
	mock.lockGetUserByEmail.Unlock()
	return mock.GetUserByEmailFunc(ctx, email)
}

// GetUserByEmailCalls gets all the calls that were made to GetUserByEmail.
// Check the length with:
//
//	len(mockedQuerier.GetUserByEmailCalls())
func (mock *QuerierMock) GetUserByEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockGetUserByEmail.RLock()
	calls = mock.calls.GetUserByEmail
	mock.lockGetUserByEmail.RUnlock()
	return calls
}

// GetUserById calls GetUserByIdFunc.
func (mock *QuerierMock) GetUserById(ctx context.Context, userID uuid.UUID) (db.GetUserByIdRow, error) {
	if mock.GetUserByIdFunc == nil {
		panic("QuerierMock.GetUserByIdFunc: method is nil but Querier.GetUserById was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockGetUserById.Lock()
	mock.calls.GetUserById = append(mock.calls.GetUserById, callInfo)
	mock.lockGetUserById.Unlock()
	return mock.GetUserByIdFunc(ctx, userID)
}

// GetUserByIdCalls gets all the calls that were made to GetUserById.
// Check the length with:
//
//	len(mockedQuerier.GetUserByIdCalls())
func (mock *QuerierMock) GetUserByIdCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockGetUserById.RLock()
	calls = mock.calls.GetUserById
	mock.lockGetUserById.RUnlock()
	return calls
}

// HardDeleteUser calls HardDeleteUserFunc.
func (mock *QuerierMock) HardDeleteUser(ctx context.Context, userID uuid.UUID) error {
	if mock.HardDeleteUserFunc == nil {
		panic("QuerierMock.HardDeleteUserFunc: method is nil but Querier.HardDeleteUser was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockHardDeleteUser.Lock()
	mock.calls.HardDeleteUser = append(mock.calls.HardDeleteUser, callInfo)
	mock.lockHardDeleteUser.Unlock()
	return mock.HardDeleteUserFunc(ctx, userID)
}

// HardDeleteUserCalls gets all the calls that were made to HardDeleteUser.
// Check the length with:
//
//	len(mockedQuerier.HardDeleteUserCalls())
func (mock *QuerierMock) HardDeleteUserCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockHardDeleteUser.RLock()
	calls = mock.calls.HardDeleteUser
	mock.lockHardDeleteUser.RUnlock()
	return calls
}

// InsertOrUpdateImage calls InsertOrUpdateImageFunc.
func (mock *QuerierMock) InsertOrUpdateImage(ctx context.Context, arg db.InsertOrUpdateImageParams) error {
	if mock.InsertOrUpdateImageFunc == nil {
		panic("QuerierMock.InsertOrUpdateImageFunc: method is nil but Querier.InsertOrUpdateImage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg db.InsertOrUpdateImageParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertOrUpdateImage.Lock()
	mock.calls.InsertOrUpdateImage = append(mock.calls.InsertOrUpdateImage, callInfo)
	mock.lockInsertOrUpdateImage.Unlock()
	return mock.InsertOrUpdateImageFunc(ctx, arg)
}

// InsertOrUpdateImageCalls gets all the calls that were made to InsertOrUpdateImage.
// Check the length with:
//
//	len(mockedQuerier.InsertOrUpdateImageCalls())
func (mock *QuerierMock) InsertOrUpdateImageCalls() []struct {
	Ctx context.Context
	Arg db.InsertOrUpdateImageParams
} {
	var calls []struct {
		Ctx context.Context
		Arg db.InsertOrUpdateImageParams
	}
	mock.lockInsertOrUpdateImage.RLock()
	calls = mock.calls.InsertOrUpdateImage
	mock.lockInsertOrUpdateImage.RUnlock()
	return calls
}

// InsertOrUpdateRoles calls InsertOrUpdateRolesFunc.
func (mock *QuerierMock) InsertOrUpdateRoles(ctx context.Context, arg db.InsertOrUpdateRolesParams) error {
	if mock.InsertOrUpdateRolesFunc == nil {
		panic("QuerierMock.InsertOrUpdateRolesFunc: method is nil but Querier.InsertOrUpdateRoles was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg db.InsertOrUpdateRolesParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertOrUpdateRoles.Lock()
	mock.calls.InsertOrUpdateRoles = append(mock.calls.InsertOrUpdateRoles, callInfo)
	mock.lockInsertOrUpdateRoles.Unlock()
	return mock.InsertOrUpdateRolesFunc(ctx, arg)
}

// InsertOrUpdateRolesCalls gets all the calls that were made to InsertOrUpdateRoles.
// Check the length with:
//
//	len(mockedQuerier.InsertOrUpdateRolesCalls())
func (mock *QuerierMock) InsertOrUpdateRolesCalls() []struct {
	Ctx context.Context
	Arg db.InsertOrUpdateRolesParams
} {
	var calls []struct {
		Ctx context.Context
		Arg db.InsertOrUpdateRolesParams
	}
	mock.lockInsertOrUpdateRoles.RLock()
	calls = mock.calls.InsertOrUpdateRoles
	mock.lockInsertOrUpdateRoles.RUnlock()
	return calls
}

// InsertOrUpdateUser calls InsertOrUpdateUserFunc.
func (mock *QuerierMock) InsertOrUpdateUser(ctx context.Context, arg db.InsertOrUpdateUserParams) error {
	if mock.InsertOrUpdateUserFunc == nil {
		panic("QuerierMock.InsertOrUpdateUserFunc: method is nil but Querier.InsertOrUpdateUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg db.InsertOrUpdateUserParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertOrUpdateUser.Lock()
	mock.calls.InsertOrUpdateUser = append(mock.calls.InsertOrUpdateUser, callInfo)
	mock.lockInsertOrUpdateUser.Unlock()
	return mock.InsertOrUpdateUserFunc(ctx, arg)
}

// InsertOrUpdateUserCalls gets all the calls that were made to InsertOrUpdateUser.
// Check the length with:
//
//	len(mockedQuerier.InsertOrUpdateUserCalls())
func (mock *QuerierMock) InsertOrUpdateUserCalls() []struct {
	Ctx context.Context
	Arg db.InsertOrUpdateUserParams
} {
	var calls []struct {
		Ctx context.Context
		Arg db.InsertOrUpdateUserParams
	}
	mock.lockInsertOrUpdateUser.RLock()
	calls = mock.calls.InsertOrUpdateUser
	mock.lockInsertOrUpdateUser.RUnlock()
	return calls
}

// SoftDeleteUser calls SoftDeleteUserFunc.
func (mock *QuerierMock) SoftDeleteUser(ctx context.Context, userID uuid.UUID) error {
	if mock.SoftDeleteUserFunc == nil {
		panic("QuerierMock.SoftDeleteUserFunc: method is nil but Querier.SoftDeleteUser was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockSoftDeleteUser.Lock()
	mock.calls.SoftDeleteUser = append(mock.calls.SoftDeleteUser, callInfo)
	mock.lockSoftDeleteUser.Unlock()
	return mock.SoftDeleteUserFunc(ctx, userID)
}

// SoftDeleteUserCalls gets all the calls that were made to SoftDeleteUser.
// Check the length with:
//
//	len(mockedQuerier.SoftDeleteUserCalls())
func (mock *QuerierMock) SoftDeleteUserCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockSoftDeleteUser.RLock()
	calls = mock.calls.SoftDeleteUser
	mock.lockSoftDeleteUser.RUnlock()
	return calls
}

// Ensure, that TransactionerMock does implement db.Transactioner.
// If this is not the case, regenerate this file with moq.
var _ db.Transactioner = &TransactionerMock{}

// TransactionerMock is a mock implementation of db.Transactioner.
//
//	func TestSomethingThatUsesTransactioner(t *testing.T) {
//
//		// make and configure a mocked db.Transactioner
//		mockedTransactioner := &TransactionerMock{
//			CheckImageExistsFunc: func(ctx context.Context, id uuid.UUID) (bool, error) {
//				panic("mock out the CheckImageExists method")
//			},
//			CheckImageHashExistsFunc: func(ctx context.Context, fileHash []byte) (bool, error) {
//				panic("mock out the CheckImageHashExists method")
//			},
//			CommitFunc: func(ctx context.Context) error {
//				panic("mock out the Commit method")
//			},
//			DeleteImageFunc: func(ctx context.Context, id uuid.UUID) error {
//				panic("mock out the DeleteImage method")
//			},
//			DeleteRoleFunc: func(ctx context.Context, id string) error {
//				panic("mock out the DeleteRole method")
//			},
//			GetAllImagesInIDSFunc: func(ctx context.Context, imageIds []uuid.UUID) ([]db.GetAllImagesInIDSRow, error) {
//				panic("mock out the GetAllImagesInIDS method")
//			},
//			GetAllRolesFunc: func(ctx context.Context) ([]db.Role, error) {
//				panic("mock out the GetAllRoles method")
//			},
//			GetAllUsersInIDSFunc: func(ctx context.Context, userIds []uuid.UUID) ([]db.GetAllUsersInIDSRow, error) {
//				panic("mock out the GetAllUsersInIDS method")
//			},
//			GetImageByIdFunc: func(ctx context.Context, id uuid.UUID) (db.Image, error) {
//				panic("mock out the GetImageById method")
//			},
//			GetManyImagesFunc: func(ctx context.Context, arg db.GetManyImagesParams) ([]db.GetManyImagesRow, error) {
//				panic("mock out the GetManyImages method")
//			},
//			GetManyUsersFunc: func(ctx context.Context, arg db.GetManyUsersParams) ([]db.GetManyUsersRow, error) {
//				panic("mock out the GetManyUsers method")
//			},
//			GetUserByEmailFunc: func(ctx context.Context, email string) (db.GetUserByEmailRow, error) {
//				panic("mock out the GetUserByEmail method")
//			},
//			GetUserByIdFunc: func(ctx context.Context, userID uuid.UUID) (db.GetUserByIdRow, error) {
//				panic("mock out the GetUserById method")
//			},
//			HardDeleteUserFunc: func(ctx context.Context, userID uuid.UUID) error {
//				panic("mock out the HardDeleteUser method")
//			},
//			InsertOrUpdateImageFunc: func(ctx context.Context, arg db.InsertOrUpdateImageParams) error {
//				panic("mock out the InsertOrUpdateImage method")
//			},
//			InsertOrUpdateRolesFunc: func(ctx context.Context, arg db.InsertOrUpdateRolesParams) error {
//				panic("mock out the InsertOrUpdateRoles method")
//			},
//			InsertOrUpdateUserFunc: func(ctx context.Context, arg db.InsertOrUpdateUserParams) error {
//				panic("mock out the InsertOrUpdateUser method")
//			},
//			RollbackFunc: func(ctx context.Context) error {
//				panic("mock out the Rollback method")
//			},
//			SoftDeleteUserFunc: func(ctx context.Context, userID uuid.UUID) error {
//				panic("mock out the SoftDeleteUser method")
//			},
//		}
//
//		// use mockedTransactioner in code that requires db.Transactioner
//		// and then make assertions.
//
//	}
type TransactionerMock struct {
	// CheckImageExistsFunc mocks the CheckImageExists method.
	CheckImageExistsFunc func(ctx context.Context, id uuid.UUID) (bool, error)

	// CheckImageHashExistsFunc mocks the CheckImageHashExists method.
	CheckImageHashExistsFunc func(ctx context.Context, fileHash []byte) (bool, error)

	// CommitFunc mocks the Commit method.
	CommitFunc func(ctx context.Context) error

	// DeleteImageFunc mocks the DeleteImage method.
	DeleteImageFunc func(ctx context.Context, id uuid.UUID) error

	// DeleteRoleFunc mocks the DeleteRole method.
	DeleteRoleFunc func(ctx context.Context, id string) error

	// GetAllImagesInIDSFunc mocks the GetAllImagesInIDS method.
	GetAllImagesInIDSFunc func(ctx context.Context, imageIds []uuid.UUID) ([]db.GetAllImagesInIDSRow, error)

	// GetAllRolesFunc mocks the GetAllRoles method.
	GetAllRolesFunc func(ctx context.Context) ([]db.Role, error)

	// GetAllUsersInIDSFunc mocks the GetAllUsersInIDS method.
	GetAllUsersInIDSFunc func(ctx context.Context, userIds []uuid.UUID) ([]db.GetAllUsersInIDSRow, error)

	// GetImageByIdFunc mocks the GetImageById method.
	GetImageByIdFunc func(ctx context.Context, id uuid.UUID) (db.Image, error)

	// GetManyImagesFunc mocks the GetManyImages method.
	GetManyImagesFunc func(ctx context.Context, arg db.GetManyImagesParams) ([]db.GetManyImagesRow, error)

	// GetManyUsersFunc mocks the GetManyUsers method.
	GetManyUsersFunc func(ctx context.Context, arg db.GetManyUsersParams) ([]db.GetManyUsersRow, error)

	// GetUserByEmailFunc mocks the GetUserByEmail method.
	GetUserByEmailFunc func(ctx context.Context, email string) (db.GetUserByEmailRow, error)

	// GetUserByIdFunc mocks the GetUserById method.
	GetUserByIdFunc func(ctx context.Context, userID uuid.UUID) (db.GetUserByIdRow, error)

	// HardDeleteUserFunc mocks the HardDeleteUser method.
	HardDeleteUserFunc func(ctx context.Context, userID uuid.UUID) error

	// InsertOrUpdateImageFunc mocks the InsertOrUpdateImage method.
	InsertOrUpdateImageFunc func(ctx context.Context, arg db.InsertOrUpdateImageParams) error

	// InsertOrUpdateRolesFunc mocks the InsertOrUpdateRoles method.
	InsertOrUpdateRolesFunc func(ctx context.Context, arg db.InsertOrUpdateRolesParams) error

	// InsertOrUpdateUserFunc mocks the InsertOrUpdateUser method.
	InsertOrUpdateUserFunc func(ctx context.Context, arg db.InsertOrUpdateUserParams) error

	// RollbackFunc mocks the Rollback method.
	RollbackFunc func(ctx context.Context) error

	// SoftDeleteUserFunc mocks the SoftDeleteUser method.
	SoftDeleteUserFunc func(ctx context.Context, userID uuid.UUID) error

	// calls tracks calls to the methods.
	calls struct {
		// CheckImageExists holds details about calls to the CheckImageExists method.
		CheckImageExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// CheckImageHashExists holds details about calls to the CheckImageHashExists method.
		CheckImageHashExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FileHash is the fileHash argument value.
			FileHash []byte
		}
		// Commit holds details about calls to the Commit method.
		Commit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// DeleteImage holds details about calls to the DeleteImage method.
		DeleteImage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// DeleteRole holds details about calls to the DeleteRole method.
		DeleteRole []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetAllImagesInIDS holds details about calls to the GetAllImagesInIDS method.
		GetAllImagesInIDS []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ImageIds is the imageIds argument value.
			ImageIds []uuid.UUID
		}
		// GetAllRoles holds details about calls to the GetAllRoles method.
		GetAllRoles []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetAllUsersInIDS holds details about calls to the GetAllUsersInIDS method.
		GetAllUsersInIDS []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserIds is the userIds argument value.
			UserIds []uuid.UUID
		}
		// GetImageById holds details about calls to the GetImageById method.
		GetImageById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetManyImages holds details about calls to the GetManyImages method.
		GetManyImages []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg db.GetManyImagesParams
		}
		// GetManyUsers holds details about calls to the GetManyUsers method.
		GetManyUsers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg db.GetManyUsersParams
		}
		// GetUserByEmail holds details about calls to the GetUserByEmail method.
		GetUserByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// GetUserById holds details about calls to the GetUserById method.
		GetUserById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
		// HardDeleteUser holds details about calls to the HardDeleteUser method.
		HardDeleteUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
		// InsertOrUpdateImage holds details about calls to the InsertOrUpdateImage method.
		InsertOrUpdateImage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg db.InsertOrUpdateImageParams
		}
		// InsertOrUpdateRoles holds details about calls to the InsertOrUpdateRoles method.
		InsertOrUpdateRoles []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg db.InsertOrUpdateRolesParams
		}
		// InsertOrUpdateUser holds details about calls to the InsertOrUpdateUser method.
		InsertOrUpdateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg db.InsertOrUpdateUserParams
		}
		// Rollback holds details about calls to the Rollback method.
		Rollback []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SoftDeleteUser holds details about calls to the SoftDeleteUser method.
		SoftDeleteUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
	}
	lockCheckImageExists     sync.RWMutex
	lockCheckImageHashExists sync.RWMutex
	lockCommit               sync.RWMutex
	lockDeleteImage          sync.RWMutex
	lockDeleteRole           sync.RWMutex
	lockGetAllImagesInIDS    sync.RWMutex
	lockGetAllRoles          sync.RWMutex
	lockGetAllUsersInIDS     sync.RWMutex
	lockGetImageById         sync.RWMutex
	lockGetManyImages        sync.RWMutex
	lockGetManyUsers         sync.RWMutex
	lockGetUserByEmail       sync.RWMutex
	lockGetUserById          sync.RWMutex
	lockHardDeleteUser       sync.RWMutex
	lockInsertOrUpdateImage  sync.RWMutex
	lockInsertOrUpdateRoles  sync.RWMutex
	lockInsertOrUpdateUser   sync.RWMutex
	lockRollback             sync.RWMutex
	lockSoftDeleteUser       sync.RWMutex
}

// CheckImageExists calls CheckImageExistsFunc.
func (mock *TransactionerMock) CheckImageExists(ctx context.Context, id uuid.UUID) (bool, error) {
	if mock.CheckImageExistsFunc == nil {
		panic("TransactionerMock.CheckImageExistsFunc: method is nil but Transactioner.CheckImageExists was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockCheckImageExists.Lock()
	mock.calls.CheckImageExists = append(mock.calls.CheckImageExists, callInfo)
	mock.lockCheckImageExists.Unlock()
	return mock.CheckImageExistsFunc(ctx, id)
}

// CheckImageExistsCalls gets all the calls that were made to CheckImageExists.
// Check the length with:
//
//	len(mockedTransactioner.CheckImageExistsCalls())
func (mock *TransactionerMock) CheckImageExistsCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockCheckImageExists.RLock()
	calls = mock.calls.CheckImageExists
	mock.lockCheckImageExists.RUnlock()
	return calls
}

// CheckImageHashExists calls CheckImageHashExistsFunc.
func (mock *TransactionerMock) CheckImageHashExists(ctx context.Context, fileHash []byte) (bool, error) {
	if mock.CheckImageHashExistsFunc == nil {
		panic("TransactionerMock.CheckImageHashExistsFunc: method is nil but Transactioner.CheckImageHashExists was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		FileHash []byte
	}{
		Ctx:      ctx,
		FileHash: fileHash,
	}
	mock.lockCheckImageHashExists.Lock()
	mock.calls.CheckImageHashExists = append(mock.calls.CheckImageHashExists, callInfo)
	mock.lockCheckImageHashExists.Unlock()
	return mock.CheckImageHashExistsFunc(ctx, fileHash)
}

// CheckImageHashExistsCalls gets all the calls that were made to CheckImageHashExists.
// Check the length with:
//
//	len(mockedTransactioner.CheckImageHashExistsCalls())
func (mock *TransactionerMock) CheckImageHashExistsCalls() []struct {
	Ctx      context.Context
	FileHash []byte
} {
	var calls []struct {
		Ctx      context.Context
		FileHash []byte
	}
	mock.lockCheckImageHashExists.RLock()
	calls = mock.calls.CheckImageHashExists
	mock.lockCheckImageHashExists.RUnlock()
	return calls
}

// Commit calls CommitFunc.
func (mock *TransactionerMock) Commit(ctx context.Context) error {
	if mock.CommitFunc == nil {
		panic("TransactionerMock.CommitFunc: method is nil but Transactioner.Commit was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCommit.Lock()
	mock.calls.Commit = append(mock.calls.Commit, callInfo)
	mock.lockCommit.Unlock()
	return mock.CommitFunc(ctx)
}

// CommitCalls gets all the calls that were made to Commit.
// Check the length with:
//
//	len(mockedTransactioner.CommitCalls())
func (mock *TransactionerMock) CommitCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCommit.RLock()
	calls = mock.calls.Commit
	mock.lockCommit.RUnlock()
	return calls
}

// DeleteImage calls DeleteImageFunc.
func (mock *TransactionerMock) DeleteImage(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteImageFunc == nil {
		panic("TransactionerMock.DeleteImageFunc: method is nil but Transactioner.DeleteImage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteImage.Lock()
	mock.calls.DeleteImage = append(mock.calls.DeleteImage, callInfo)
	mock.lockDeleteImage.Unlock()
	return mock.DeleteImageFunc(ctx, id)
}

// DeleteImageCalls gets all the calls that were made to DeleteImage.
// Check the length with:
//
//	len(mockedTransactioner.DeleteImageCalls())
func (mock *TransactionerMock) DeleteImageCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDeleteImage.RLock()
	calls = mock.calls.DeleteImage
	mock.lockDeleteImage.RUnlock()
	return calls
}

// DeleteRole calls DeleteRoleFunc.
func (mock *TransactionerMock) DeleteRole(ctx context.Context, id string) error {
	if mock.DeleteRoleFunc == nil {
		panic("TransactionerMock.DeleteRoleFunc: method is nil but Transactioner.DeleteRole was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteRole.Lock()
	mock.calls.DeleteRole = append(mock.calls.DeleteRole, callInfo)
	mock.lockDeleteRole.Unlock()
	return mock.DeleteRoleFunc(ctx, id)
}

// DeleteRoleCalls gets all the calls that were made to DeleteRole.
// Check the length with:
//
//	len(mockedTransactioner.DeleteRoleCalls())
func (mock *TransactionerMock) DeleteRoleCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockDeleteRole.RLock()
	calls = mock.calls.DeleteRole
	mock.lockDeleteRole.RUnlock()
	return calls
}

// GetAllImagesInIDS calls GetAllImagesInIDSFunc.
func (mock *TransactionerMock) GetAllImagesInIDS(ctx context.Context, imageIds []uuid.UUID) ([]db.GetAllImagesInIDSRow, error) {
	if mock.GetAllImagesInIDSFunc == nil {
		panic("TransactionerMock.GetAllImagesInIDSFunc: method is nil but Transactioner.GetAllImagesInIDS was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		ImageIds []uuid.UUID
	}{
		Ctx:      ctx,
		ImageIds: imageIds,
	}
	mock.lockGetAllImagesInIDS.Lock()
	mock.calls.GetAllImagesInIDS = append(mock.calls.GetAllImagesInIDS, callInfo)
	mock.lockGetAllImagesInIDS.Unlock()
	return mock.GetAllImagesInIDSFunc(ctx, imageIds)
}

// GetAllImagesInIDSCalls gets all the calls that were made to GetAllImagesInIDS.
// Check the length with:
//
//	len(mockedTransactioner.GetAllImagesInIDSCalls())
func (mock *TransactionerMock) GetAllImagesInIDSCalls() []struct {
	Ctx      context.Context
	ImageIds []uuid.UUID
} {
	var calls []struct {
		Ctx      context.Context
		ImageIds []uuid.UUID
	}
	mock.lockGetAllImagesInIDS.RLock()
	calls = mock.calls.GetAllImagesInIDS
	mock.lockGetAllImagesInIDS.RUnlock()
	return calls
}

// GetAllRoles calls GetAllRolesFunc.
func (mock *TransactionerMock) GetAllRoles(ctx context.Context) ([]db.Role, error) {
	if mock.GetAllRolesFunc == nil {
		panic("TransactionerMock.GetAllRolesFunc: method is nil but Transactioner.GetAllRoles was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllRoles.Lock()
	mock.calls.GetAllRoles = append(mock.calls.GetAllRoles, callInfo)
	mock.lockGetAllRoles.Unlock()
	return mock.GetAllRolesFunc(ctx)
}

// GetAllRolesCalls gets all the calls that were made to GetAllRoles.
// Check the length with:
//
//	len(mockedTransactioner.GetAllRolesCalls())
func (mock *TransactionerMock) GetAllRolesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAllRoles.RLock()
	calls = mock.calls.GetAllRoles
	mock.lockGetAllRoles.RUnlock()
	return calls
}

// GetAllUsersInIDS calls GetAllUsersInIDSFunc.
func (mock *TransactionerMock) GetAllUsersInIDS(ctx context.Context, userIds []uuid.UUID) ([]db.GetAllUsersInIDSRow, error) {
	if mock.GetAllUsersInIDSFunc == nil {
		panic("TransactionerMock.GetAllUsersInIDSFunc: method is nil but Transactioner.GetAllUsersInIDS was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		UserIds []uuid.UUID
	}{
		Ctx:     ctx,
		UserIds: userIds,
	}
	mock.lockGetAllUsersInIDS.Lock()
	mock.calls.GetAllUsersInIDS = append(mock.calls.GetAllUsersInIDS, callInfo)
	mock.lockGetAllUsersInIDS.Unlock()
	return mock.GetAllUsersInIDSFunc(ctx, userIds)
}

// GetAllUsersInIDSCalls gets all the calls that were made to GetAllUsersInIDS.
// Check the length with:
//
//	len(mockedTransactioner.GetAllUsersInIDSCalls())
func (mock *TransactionerMock) GetAllUsersInIDSCalls() []struct {
	Ctx     context.Context
	UserIds []uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		UserIds []uuid.UUID
	}
	mock.lockGetAllUsersInIDS.RLock()
	calls = mock.calls.GetAllUsersInIDS
	mock.lockGetAllUsersInIDS.RUnlock()
	return calls
}

// GetImageById calls GetImageByIdFunc.
func (mock *TransactionerMock) GetImageById(ctx context.Context, id uuid.UUID) (db.Image, error) {
	if mock.GetImageByIdFunc == nil {
		panic("TransactionerMock.GetImageByIdFunc: method is nil but Transactioner.GetImageById was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetImageById.Lock()
	mock.calls.GetImageById = append(mock.calls.GetImageById, callInfo)
	mock.lockGetImageById.Unlock()
	return mock.GetImageByIdFunc(ctx, id)
}

// GetImageByIdCalls gets all the calls that were made to GetImageById.
// Check the length with:
//
//	len(mockedTransactioner.GetImageByIdCalls())
func (mock *TransactionerMock) GetImageByIdCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetImageById.RLock()
	calls = mock.calls.GetImageById
	mock.lockGetImageById.RUnlock()
	return calls
}

// GetManyImages calls GetManyImagesFunc.
func (mock *TransactionerMock) GetManyImages(ctx context.Context, arg db.GetManyImagesParams) ([]db.GetManyImagesRow, error) {
	if mock.GetManyImagesFunc == nil {
		panic("TransactionerMock.GetManyImagesFunc: method is nil but Transactioner.GetManyImages was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg db.GetManyImagesParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockGetManyImages.Lock()
	mock.calls.GetManyImages = append(mock.calls.GetManyImages, callInfo)
	mock.lockGetManyImages.Unlock()
	return mock.GetManyImagesFunc(ctx, arg)
}

// GetManyImagesCalls gets all the calls that were made to GetManyImages.
// Check the length with:
//
//	len(mockedTransactioner.GetManyImagesCalls())
func (mock *TransactionerMock) GetManyImagesCalls() []struct {
	Ctx context.Context
	Arg db.GetManyImagesParams
} {
	var calls []struct {
		Ctx context.Context
		Arg db.GetManyImagesParams
	}
	mock.lockGetManyImages.RLock()
	calls = mock.calls.GetManyImages
	mock.lockGetManyImages.RUnlock()
	return calls
}

// GetManyUsers calls GetManyUsersFunc.
func (mock *TransactionerMock) GetManyUsers(ctx context.Context, arg db.GetManyUsersParams) ([]db.GetManyUsersRow, error) {
	if mock.GetManyUsersFunc == nil {
		panic("TransactionerMock.GetManyUsersFunc: method is nil but Transactioner.GetManyUsers was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg db.GetManyUsersParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockGetManyUsers.Lock()
	mock.calls.GetManyUsers = append(mock.calls.GetManyUsers, callInfo)
	mock.lockGetManyUsers.Unlock()
	return mock.GetManyUsersFunc(ctx, arg)
}

// GetManyUsersCalls gets all the calls that were made to GetManyUsers.
// Check the length with:
//
//	len(mockedTransactioner.GetManyUsersCalls())
func (mock *TransactionerMock) GetManyUsersCalls() []struct {
	Ctx context.Context
	Arg db.GetManyUsersParams
} {
	var calls []struct {
		Ctx context.Context
		Arg db.GetManyUsersParams
	}
	mock.lockGetManyUsers.RLock()
	calls = mock.calls.GetManyUsers
	mock.lockGetManyUsers.RUnlock()
	return calls
}

// GetUserByEmail calls GetUserByEmailFunc.
func (mock *TransactionerMock) GetUserByEmail(ctx context.Context, email string) (db.GetUserByEmailRow, error) {
	if mock.GetUserByEmailFunc == nil {
		panic("TransactionerMock.GetUserByEmailFunc: method is nil but Transactioner.GetUserByEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockGetUserByEmail.Lock()
	mock.calls.GetUserByEmail = append(mock.calls.GetUserByEmail, callInfo)
	mock.lockGetUserByEmail.Unlock()
	return mock.GetUserByEmailFunc(ctx, email)
}

// GetUserByEmailCalls gets all the calls that were made to GetUserByEmail.
// Check the length with:
//
//	len(mockedTransactioner.GetUserByEmailCalls())
func (mock *TransactionerMock) GetUserByEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockGetUserByEmail.RLock()
	calls = mock.calls.GetUserByEmail
	mock.lockGetUserByEmail.RUnlock()
	return calls
}

// GetUserById calls GetUserByIdFunc.
func (mock *TransactionerMock) GetUserById(ctx context.Context, userID uuid.UUID) (db.GetUserByIdRow, error) {
	if mock.GetUserByIdFunc == nil {
		panic("TransactionerMock.GetUserByIdFunc: method is nil but Transactioner.GetUserById was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockGetUserById.Lock()
	mock.calls.GetUserById = append(mock.calls.GetUserById, callInfo)
	mock.lockGetUserById.Unlock()
	return mock.GetUserByIdFunc(ctx, userID)
}

// GetUserByIdCalls gets all the calls that were made to GetUserById.
// Check the length with:
//
//	len(mockedTransactioner.GetUserByIdCalls())
func (mock *TransactionerMock) GetUserByIdCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockGetUserById.RLock()
	calls = mock.calls.GetUserById
	mock.lockGetUserById.RUnlock()
	return calls
}

// HardDeleteUser calls HardDeleteUserFunc.
func (mock *TransactionerMock) HardDeleteUser(ctx context.Context, userID uuid.UUID) error {
	if mock.HardDeleteUserFunc == nil {
		panic("TransactionerMock.HardDeleteUserFunc: method is nil but Transactioner.HardDeleteUser was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockHardDeleteUser.Lock()
	mock.calls.HardDeleteUser = append(mock.calls.HardDeleteUser, callInfo)
	mock.lockHardDeleteUser.Unlock()
	return mock.HardDeleteUserFunc(ctx, userID)
}

// HardDeleteUserCalls gets all the calls that were made to HardDeleteUser.
// Check the length with:
//
//	len(mockedTransactioner.HardDeleteUserCalls())
func (mock *TransactionerMock) HardDeleteUserCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockHardDeleteUser.RLock()
	calls = mock.calls.HardDeleteUser
	mock.lockHardDeleteUser.RUnlock()
	return calls
}

// InsertOrUpdateImage calls InsertOrUpdateImageFunc.
func (mock *TransactionerMock) InsertOrUpdateImage(ctx context.Context, arg db.InsertOrUpdateImageParams) error {
	if mock.InsertOrUpdateImageFunc == nil {
		panic("TransactionerMock.InsertOrUpdateImageFunc: method is nil but Transactioner.InsertOrUpdateImage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg db.InsertOrUpdateImageParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertOrUpdateImage.Lock()
	mock.calls.InsertOrUpdateImage = append(mock.calls.InsertOrUpdateImage, callInfo)
	mock.lockInsertOrUpdateImage.Unlock()
	return mock.InsertOrUpdateImageFunc(ctx, arg)
}

// InsertOrUpdateImageCalls gets all the calls that were made to InsertOrUpdateImage.
// Check the length with:
//
//	len(mockedTransactioner.InsertOrUpdateImageCalls())
func (mock *TransactionerMock) InsertOrUpdateImageCalls() []struct {
	Ctx context.Context
	Arg db.InsertOrUpdateImageParams
} {
	var calls []struct {
		Ctx context.Context
		Arg db.InsertOrUpdateImageParams
	}
	mock.lockInsertOrUpdateImage.RLock()
	calls = mock.calls.InsertOrUpdateImage
	mock.lockInsertOrUpdateImage.RUnlock()
	return calls
}

// InsertOrUpdateRoles calls InsertOrUpdateRolesFunc.
func (mock *TransactionerMock) InsertOrUpdateRoles(ctx context.Context, arg db.InsertOrUpdateRolesParams) error {
	if mock.InsertOrUpdateRolesFunc == nil {
		panic("TransactionerMock.InsertOrUpdateRolesFunc: method is nil but Transactioner.InsertOrUpdateRoles was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg db.InsertOrUpdateRolesParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertOrUpdateRoles.Lock()
	mock.calls.InsertOrUpdateRoles = append(mock.calls.InsertOrUpdateRoles, callInfo)
	mock.lockInsertOrUpdateRoles.Unlock()
	return mock.InsertOrUpdateRolesFunc(ctx, arg)
}

// InsertOrUpdateRolesCalls gets all the calls that were made to InsertOrUpdateRoles.
// Check the length with:
//
//	len(mockedTransactioner.InsertOrUpdateRolesCalls())
func (mock *TransactionerMock) InsertOrUpdateRolesCalls() []struct {
	Ctx context.Context
	Arg db.InsertOrUpdateRolesParams
} {
	var calls []struct {
		Ctx context.Context
		Arg db.InsertOrUpdateRolesParams
	}
	mock.lockInsertOrUpdateRoles.RLock()
	calls = mock.calls.InsertOrUpdateRoles
	mock.lockInsertOrUpdateRoles.RUnlock()
	return calls
}

// InsertOrUpdateUser calls InsertOrUpdateUserFunc.
func (mock *TransactionerMock) InsertOrUpdateUser(ctx context.Context, arg db.InsertOrUpdateUserParams) error {
	if mock.InsertOrUpdateUserFunc == nil {
		panic("TransactionerMock.InsertOrUpdateUserFunc: method is nil but Transactioner.InsertOrUpdateUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg db.InsertOrUpdateUserParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertOrUpdateUser.Lock()
	mock.calls.InsertOrUpdateUser = append(mock.calls.InsertOrUpdateUser, callInfo)
	mock.lockInsertOrUpdateUser.Unlock()
	return mock.InsertOrUpdateUserFunc(ctx, arg)
}

// InsertOrUpdateUserCalls gets all the calls that were made to InsertOrUpdateUser.
// Check the length with:
//
//	len(mockedTransactioner.InsertOrUpdateUserCalls())
func (mock *TransactionerMock) InsertOrUpdateUserCalls() []struct {
	Ctx context.Context
	Arg db.InsertOrUpdateUserParams
} {
	var calls []struct {
		Ctx context.Context
		Arg db.InsertOrUpdateUserParams
	}
	mock.lockInsertOrUpdateUser.RLock()
	calls = mock.calls.InsertOrUpdateUser
	mock.lockInsertOrUpdateUser.RUnlock()
	return calls
}

// Rollback calls RollbackFunc.
func (mock *TransactionerMock) Rollback(ctx context.Context) error {
	if mock.RollbackFunc == nil {
		panic("TransactionerMock.RollbackFunc: method is nil but Transactioner.Rollback was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRollback.Lock()
	mock.calls.Rollback = append(mock.calls.Rollback, callInfo)
	mock.lockRollback.Unlock()
	return mock.RollbackFunc(ctx)
}

// RollbackCalls gets all the calls that were made to Rollback.
// Check the length with:
//
//	len(mockedTransactioner.RollbackCalls())
func (mock *TransactionerMock) RollbackCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRollback.RLock()
	calls = mock.calls.Rollback
	mock.lockRollback.RUnlock()
	return calls
}

// SoftDeleteUser calls SoftDeleteUserFunc.
func (mock *TransactionerMock) SoftDeleteUser(ctx context.Context, userID uuid.UUID) error {
	if mock.SoftDeleteUserFunc == nil {
		panic("TransactionerMock.SoftDeleteUserFunc: method is nil but Transactioner.SoftDeleteUser was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockSoftDeleteUser.Lock()
	mock.calls.SoftDeleteUser = append(mock.calls.SoftDeleteUser, callInfo)
	mock.lockSoftDeleteUser.Unlock()
	return mock.SoftDeleteUserFunc(ctx, userID)
}

// SoftDeleteUserCalls gets all the calls that were made to SoftDeleteUser.
// Check the length with:
//
//	len(mockedTransactioner.SoftDeleteUserCalls())
func (mock *TransactionerMock) SoftDeleteUserCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockSoftDeleteUser.RLock()
	calls = mock.calls.SoftDeleteUser
	mock.lockSoftDeleteUser.RUnlock()
	return calls
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: user_queries.sql

package postgres

import (
	"context"
	"time"

	"github.com/google/uuid"
	null "gopkg.in/guregu/null.v4"
)

const deleteAllUsers = `-- name: DeleteAllUsers :exec
DELETE FROM users
`

func (q *Queries) DeleteAllUsers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllUsers)
	return err
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT 
id, 
username, 
email, 
full_name,
role_id,
picture_id,
created_at,
updated_at,
deleted_at
FROM users
WHERE $1::UUID[] IS NULL OR id = ANY($1::UUID[])
`

type GetAllUsersRow struct {
	ID        uuid.UUID
	Username  string
	Email     string
	FullName  string
	RoleID    int32
	PictureID uuid.NullUUID
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt null.Time
}

func (q *Queries) GetAllUsers(ctx context.Context, userIds []uuid.UUID) ([]GetAllUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllUsers, userIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersRow
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.FullName,
			&i.RoleID,
			&i.PictureID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT 
id, 
username, 
email, 
full_name,
role_id,
password_hash,
picture_id,
created_at,
updated_at,
deleted_at
FROM users 
WHERE
email = $1::TEXT
LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.FullName,
		&i.RoleID,
		&i.PasswordHash,
		&i.PictureID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT 
id, 
username, 
email, 
full_name,
role_id,
password_hash,
picture_id,
created_at,
updated_at,
deleted_at
FROM users 
WHERE
id = $1::UUID
LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, userID uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, userID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.FullName,
		&i.RoleID,
		&i.PasswordHash,
		&i.PictureID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const hardDeleteUser = `-- name: HardDeleteUser :exec
DELETE FROM users WHERE id = $1::UUID
`

func (q *Queries) HardDeleteUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteUser, userID)
	return err
}

const insertOrUpdateUser = `-- name: InsertOrUpdateUser :exec
INSERT INTO users (
  id, 
  username, 
  email, 
  full_name, 
  role_id,
  password_hash,
  picture_id,
  created_at, 
  updated_at
) VALUES (
  $1::UUID,
  $2::TEXT,
  $3::TEXT,
  $4::TEXT,
  $5::INTEGER,
  $6::TEXT,
  $7::UUID,
  $8::TIMESTAMPTZ,
  $9::TIMESTAMPTZ
)
ON CONFLICT (id)
DO 
UPDATE SET 
  username = EXCLUDED.username,
  full_name = EXCLUDED.full_name,
  role_id = EXCLUDED.role_id,
  password_hash = EXCLUDED.password_hash,
  picture_id = EXCLUDED.picture_id,
  updated_at = EXCLUDED.updated_at
`

type InsertOrUpdateUserParams struct {
	ID           uuid.UUID
	Username     string
	Email        string
	FullName     string
	RoleID       int32
	PasswordHash string
	PictureID    uuid.NullUUID
	CreatedAt    time.Time
	UpdatedAt    time.Time
}

func (q *Queries) InsertOrUpdateUser(ctx context.Context, arg InsertOrUpdateUserParams) error {
	_, err := q.db.Exec(ctx, insertOrUpdateUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.FullName,
		arg.RoleID,
		arg.PasswordHash,
		arg.PictureID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const softDeleteUser = `-- name: SoftDeleteUser :exec
UPDATE users
SET
deleted_at = NOW()
WHERE id = $1::UUID
`

func (q *Queries) SoftDeleteUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteUser, userID)
	return err
}

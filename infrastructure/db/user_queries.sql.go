// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: user_queries.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	null "gopkg.in/guregu/null.v4"
)

const getAllUsersInIDS = `-- name: GetAllUsersInIDS :many
SELECT 
id, 
username, 
email, 
full_name,
role,
picture_id,
created_at,
updated_at,
deleted_at
FROM users
WHERE $1::UUID[] IS NULL OR id = ANY($1::UUID[])
`

type GetAllUsersInIDSRow struct {
	ID        uuid.UUID
	Username  string
	Email     string
	FullName  string
	Role      string
	PictureID uuid.NullUUID
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt null.Time
}

func (q *Queries) GetAllUsersInIDS(ctx context.Context, userIds []uuid.UUID) ([]GetAllUsersInIDSRow, error) {
	rows, err := q.db.Query(ctx, getAllUsersInIDS, userIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersInIDSRow
	for rows.Next() {
		var i GetAllUsersInIDSRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.FullName,
			&i.Role,
			&i.PictureID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManyUsers = `-- name: GetManyUsers :many
SELECT
id,
username,
email,
full_name,
role,
picture_id,
created_at,
updated_at,
deleted_at
FROM 
  users, 
  to_tsquery('simple', array_to_string(string_to_array($1::TEXT, ' '), '&')) query,
  SIMILARITY($1::TEXT, email || full_name || username) sm,
  GREATEST(ts_rank(search_index, query), sm) ranking
WHERE
  (query IS NULL OR (query @@ search_index) OR sm > 0.1) AND
  ($2::TEXT IS NULL OR role = $2::TEXT) AND
  ($3::TIMESTAMPTZ IS NULL OR updated_at < $3::TIMESTAMPTZ) AND
  ($4::BOOLEAN OR deleted_at IS NULL)
ORDER BY 
ranking DESC,
updated_at DESC
LIMIT $5::BIGINT
`

type GetManyUsersParams struct {
	Search        null.String
	Role          null.String
	UpdatedBefore null.Time
	ShowDeleted   bool
	UsersLimit    int64
}

type GetManyUsersRow struct {
	ID        uuid.UUID
	Username  string
	Email     string
	FullName  string
	Role      string
	PictureID uuid.NullUUID
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt null.Time
}

func (q *Queries) GetManyUsers(ctx context.Context, arg GetManyUsersParams) ([]GetManyUsersRow, error) {
	rows, err := q.db.Query(ctx, getManyUsers,
		arg.Search,
		arg.Role,
		arg.UpdatedBefore,
		arg.ShowDeleted,
		arg.UsersLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetManyUsersRow
	for rows.Next() {
		var i GetManyUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.FullName,
			&i.Role,
			&i.PictureID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT 
id, 
username, 
email, 
full_name,
role,
password_hash,
picture_id,
created_at,
updated_at,
deleted_at
FROM users
WHERE
email = $1::TEXT
LIMIT 1
`

type GetUserByEmailRow struct {
	ID           uuid.UUID
	Username     string
	Email        string
	FullName     string
	Role         string
	PasswordHash string
	PictureID    uuid.NullUUID
	CreatedAt    time.Time
	UpdatedAt    time.Time
	DeletedAt    null.Time
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.FullName,
		&i.Role,
		&i.PasswordHash,
		&i.PictureID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT 
id, 
username, 
email, 
full_name,
role,
password_hash,
picture_id,
created_at,
updated_at,
deleted_at
FROM users
WHERE
id = $1::UUID
LIMIT 1
`

type GetUserByIdRow struct {
	ID           uuid.UUID
	Username     string
	Email        string
	FullName     string
	Role         string
	PasswordHash string
	PictureID    uuid.NullUUID
	CreatedAt    time.Time
	UpdatedAt    time.Time
	DeletedAt    null.Time
}

func (q *Queries) GetUserById(ctx context.Context, userID uuid.UUID) (GetUserByIdRow, error) {
	row := q.db.QueryRow(ctx, getUserById, userID)
	var i GetUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.FullName,
		&i.Role,
		&i.PasswordHash,
		&i.PictureID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const hardDeleteUser = `-- name: HardDeleteUser :exec
DELETE FROM users WHERE id = $1::UUID
`

func (q *Queries) HardDeleteUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteUser, userID)
	return err
}

const insertOrUpdateUser = `-- name: InsertOrUpdateUser :exec
INSERT INTO users (
  id, 
  username, 
  email, 
  full_name, 
  role,
  password_hash,
  picture_id,
  created_at, 
  updated_at
) VALUES (
  $1::UUID,
  $2::TEXT,
  $3::TEXT,
  $4::TEXT,
  $5::TEXT,
  $6::TEXT,
  $7::UUID,
  $8::TIMESTAMPTZ,
  $9::TIMESTAMPTZ
)
ON CONFLICT (id)
DO 
UPDATE SET 
  username = EXCLUDED.username,
  full_name = EXCLUDED.full_name,
  role = EXCLUDED.role,
  password_hash = EXCLUDED.password_hash,
  picture_id = EXCLUDED.picture_id,
  updated_at = EXCLUDED.updated_at
`

type InsertOrUpdateUserParams struct {
	ID           uuid.UUID
	Username     string
	Email        string
	FullName     string
	Role         string
	PasswordHash string
	PictureID    uuid.NullUUID
	CreatedAt    time.Time
	UpdatedAt    time.Time
}

func (q *Queries) InsertOrUpdateUser(ctx context.Context, arg InsertOrUpdateUserParams) error {
	_, err := q.db.Exec(ctx, insertOrUpdateUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.FullName,
		arg.Role,
		arg.PasswordHash,
		arg.PictureID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const softDeleteUser = `-- name: SoftDeleteUser :exec
UPDATE users
SET
deleted_at = NOW()
WHERE id = $1::UUID
`

func (q *Queries) SoftDeleteUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteUser, userID)
	return err
}

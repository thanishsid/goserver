// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: video_queries.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	null "gopkg.in/guregu/null.v4"
)

const checkVideoExists = `-- name: CheckVideoExists :one
SELECT EXISTS(SELECT 1 FROM videos WHERE id = $1::UUID)
`

func (q *Queries) CheckVideoExists(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkVideoExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkVideoFileExists = `-- name: CheckVideoFileExists :one
SELECT EXISTS(SELECT 1 FROM videos WHERE file_name = $1::TEXT)
`

func (q *Queries) CheckVideoFileExists(ctx context.Context, fileName string) (bool, error) {
	row := q.db.QueryRow(ctx, checkVideoFileExists, fileName)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const deleteVideo = `-- name: DeleteVideo :exec
DELETE FROM videos WHERE id = $1::UUID
`

func (q *Queries) DeleteVideo(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteVideo, id)
	return err
}

const getAllVideosInIDS = `-- name: GetAllVideosInIDS :many
SELECT 
    id, 
    file_name, 
    thumbnail_id,
    created_at, 
    updated_at
FROM videos
WHERE $1::UUID[] IS NULL OR id = ANY($1::UUID[])
`

func (q *Queries) GetAllVideosInIDS(ctx context.Context, videoIds []uuid.UUID) ([]Video, error) {
	rows, err := q.db.Query(ctx, getAllVideosInIDS, videoIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Video
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.ThumbnailID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManyVideos = `-- name: GetManyVideos :many
SELECT 
    id, 
    file_name,
    thumbnail_id,
    created_at, 
    updated_at
FROM videos
WHERE
$1::TIMESTAMPTZ IS NULL OR updated_at < $1::TIMESTAMPTZ
ORDER BY updated_at DESC
LIMIT $2::BIGINT
`

type GetManyVideosParams struct {
	UpdatedBefore null.Time
	ImageLimit    int64
}

func (q *Queries) GetManyVideos(ctx context.Context, arg GetManyVideosParams) ([]Video, error) {
	rows, err := q.db.Query(ctx, getManyVideos, arg.UpdatedBefore, arg.ImageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Video
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.ThumbnailID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVideoById = `-- name: GetVideoById :one
SELECT 
id, 
file_name, 
thumbnail_id,
created_at, 
updated_at
FROM videos
WHERE id = $1::UUID
`

func (q *Queries) GetVideoById(ctx context.Context, id uuid.UUID) (Video, error) {
	row := q.db.QueryRow(ctx, getVideoById, id)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.ThumbnailID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertOrUpdateVideo = `-- name: InsertOrUpdateVideo :exec
INSERT INTO videos (
    id,
    file_name,
    thumbnail_id,
    created_at,
    updated_at
) VALUES (
    $1::UUID,
    $2::TEXT,
    $3::UUID,
    $4::TIMESTAMPTZ,
    $5::TIMESTAMPTZ
) ON CONFLICT (id)
DO UPDATE
SET
    file_name = EXCLUDED.file_name,
    thumbnail_id = EXCLUDED.thumbnail_id,
    updated_at = EXCLUDED.updated_at
`

type InsertOrUpdateVideoParams struct {
	ID          uuid.UUID
	FileName    string
	ThumbnailID uuid.UUID
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) InsertOrUpdateVideo(ctx context.Context, arg InsertOrUpdateVideoParams) error {
	_, err := q.db.Exec(ctx, insertOrUpdateVideo,
		arg.ID,
		arg.FileName,
		arg.ThumbnailID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package db

import (
	"context"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v4"
	"sync"
)

// Ensure, that DBMock does implement DB.
// If this is not the case, regenerate this file with moq.
var _ DB = &DBMock{}

// DBMock is a mock implementation of DB.
//
//	func TestSomethingThatUsesDB(t *testing.T) {
//
//		// make and configure a mocked DB
//		mockedDB := &DBMock{
//			BeginTxFunc: func(ctx context.Context, txOpts pgx.TxOptions) (Transactioner, error) {
//				panic("mock out the BeginTx method")
//			},
//			CheckImageExistsFunc: func(ctx context.Context, id uuid.UUID) (bool, error) {
//				panic("mock out the CheckImageExists method")
//			},
//			CheckImageHashExistsFunc: func(ctx context.Context, fileHash []byte) (bool, error) {
//				panic("mock out the CheckImageHashExists method")
//			},
//			DeleteImageFunc: func(ctx context.Context, id uuid.UUID) error {
//				panic("mock out the DeleteImage method")
//			},
//			DeleteRoleFunc: func(ctx context.Context, id string) error {
//				panic("mock out the DeleteRole method")
//			},
//			GetAllImagesInIDSFunc: func(ctx context.Context, imageIds []uuid.UUID) ([]GetAllImagesInIDSRow, error) {
//				panic("mock out the GetAllImagesInIDS method")
//			},
//			GetAllRolesFunc: func(ctx context.Context) ([]Role, error) {
//				panic("mock out the GetAllRoles method")
//			},
//			GetAllUsersInIDSFunc: func(ctx context.Context, userIds []uuid.UUID) ([]GetAllUsersInIDSRow, error) {
//				panic("mock out the GetAllUsersInIDS method")
//			},
//			GetImageByIdFunc: func(ctx context.Context, id uuid.UUID) (Image, error) {
//				panic("mock out the GetImageById method")
//			},
//			GetManyImagesFunc: func(ctx context.Context, arg GetManyImagesParams) ([]GetManyImagesRow, error) {
//				panic("mock out the GetManyImages method")
//			},
//			GetManyUsersFunc: func(ctx context.Context, arg GetManyUsersParams) ([]GetManyUsersRow, error) {
//				panic("mock out the GetManyUsers method")
//			},
//			GetUserByEmailFunc: func(ctx context.Context, email string) (GetUserByEmailRow, error) {
//				panic("mock out the GetUserByEmail method")
//			},
//			GetUserByIdFunc: func(ctx context.Context, userID uuid.UUID) (GetUserByIdRow, error) {
//				panic("mock out the GetUserById method")
//			},
//			GetUsersCountFunc: func(ctx context.Context) (int64, error) {
//				panic("mock out the GetUsersCount method")
//			},
//			GetUsersCountByRoleFunc: func(ctx context.Context, userRole string) (int64, error) {
//				panic("mock out the GetUsersCountByRole method")
//			},
//			HardDeleteUserFunc: func(ctx context.Context, userID uuid.UUID) error {
//				panic("mock out the HardDeleteUser method")
//			},
//			InsertOrUpdateImageFunc: func(ctx context.Context, arg InsertOrUpdateImageParams) error {
//				panic("mock out the InsertOrUpdateImage method")
//			},
//			InsertOrUpdateRolesFunc: func(ctx context.Context, arg InsertOrUpdateRolesParams) error {
//				panic("mock out the InsertOrUpdateRoles method")
//			},
//			InsertOrUpdateUserFunc: func(ctx context.Context, arg InsertOrUpdateUserParams) error {
//				panic("mock out the InsertOrUpdateUser method")
//			},
//			SoftDeleteUserFunc: func(ctx context.Context, userID uuid.UUID) error {
//				panic("mock out the SoftDeleteUser method")
//			},
//		}
//
//		// use mockedDB in code that requires DB
//		// and then make assertions.
//
//	}
type DBMock struct {
	// BeginTxFunc mocks the BeginTx method.
	BeginTxFunc func(ctx context.Context, txOpts pgx.TxOptions) (Transactioner, error)

	// CheckImageExistsFunc mocks the CheckImageExists method.
	CheckImageExistsFunc func(ctx context.Context, id uuid.UUID) (bool, error)

	// CheckImageHashExistsFunc mocks the CheckImageHashExists method.
	CheckImageHashExistsFunc func(ctx context.Context, fileHash []byte) (bool, error)

	// DeleteImageFunc mocks the DeleteImage method.
	DeleteImageFunc func(ctx context.Context, id uuid.UUID) error

	// DeleteRoleFunc mocks the DeleteRole method.
	DeleteRoleFunc func(ctx context.Context, id string) error

	// GetAllImagesInIDSFunc mocks the GetAllImagesInIDS method.
	GetAllImagesInIDSFunc func(ctx context.Context, imageIds []uuid.UUID) ([]GetAllImagesInIDSRow, error)

	// GetAllRolesFunc mocks the GetAllRoles method.
	GetAllRolesFunc func(ctx context.Context) ([]Role, error)

	// GetAllUsersInIDSFunc mocks the GetAllUsersInIDS method.
	GetAllUsersInIDSFunc func(ctx context.Context, userIds []uuid.UUID) ([]GetAllUsersInIDSRow, error)

	// GetImageByIdFunc mocks the GetImageById method.
	GetImageByIdFunc func(ctx context.Context, id uuid.UUID) (Image, error)

	// GetManyImagesFunc mocks the GetManyImages method.
	GetManyImagesFunc func(ctx context.Context, arg GetManyImagesParams) ([]GetManyImagesRow, error)

	// GetManyUsersFunc mocks the GetManyUsers method.
	GetManyUsersFunc func(ctx context.Context, arg GetManyUsersParams) ([]GetManyUsersRow, error)

	// GetUserByEmailFunc mocks the GetUserByEmail method.
	GetUserByEmailFunc func(ctx context.Context, email string) (GetUserByEmailRow, error)

	// GetUserByIdFunc mocks the GetUserById method.
	GetUserByIdFunc func(ctx context.Context, userID uuid.UUID) (GetUserByIdRow, error)

	// GetUsersCountFunc mocks the GetUsersCount method.
	GetUsersCountFunc func(ctx context.Context) (int64, error)

	// GetUsersCountByRoleFunc mocks the GetUsersCountByRole method.
	GetUsersCountByRoleFunc func(ctx context.Context, userRole string) (int64, error)

	// HardDeleteUserFunc mocks the HardDeleteUser method.
	HardDeleteUserFunc func(ctx context.Context, userID uuid.UUID) error

	// InsertOrUpdateImageFunc mocks the InsertOrUpdateImage method.
	InsertOrUpdateImageFunc func(ctx context.Context, arg InsertOrUpdateImageParams) error

	// InsertOrUpdateRolesFunc mocks the InsertOrUpdateRoles method.
	InsertOrUpdateRolesFunc func(ctx context.Context, arg InsertOrUpdateRolesParams) error

	// InsertOrUpdateUserFunc mocks the InsertOrUpdateUser method.
	InsertOrUpdateUserFunc func(ctx context.Context, arg InsertOrUpdateUserParams) error

	// SoftDeleteUserFunc mocks the SoftDeleteUser method.
	SoftDeleteUserFunc func(ctx context.Context, userID uuid.UUID) error

	// calls tracks calls to the methods.
	calls struct {
		// BeginTx holds details about calls to the BeginTx method.
		BeginTx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxOpts is the txOpts argument value.
			TxOpts pgx.TxOptions
		}
		// CheckImageExists holds details about calls to the CheckImageExists method.
		CheckImageExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// CheckImageHashExists holds details about calls to the CheckImageHashExists method.
		CheckImageHashExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FileHash is the fileHash argument value.
			FileHash []byte
		}
		// DeleteImage holds details about calls to the DeleteImage method.
		DeleteImage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// DeleteRole holds details about calls to the DeleteRole method.
		DeleteRole []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetAllImagesInIDS holds details about calls to the GetAllImagesInIDS method.
		GetAllImagesInIDS []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ImageIds is the imageIds argument value.
			ImageIds []uuid.UUID
		}
		// GetAllRoles holds details about calls to the GetAllRoles method.
		GetAllRoles []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetAllUsersInIDS holds details about calls to the GetAllUsersInIDS method.
		GetAllUsersInIDS []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserIds is the userIds argument value.
			UserIds []uuid.UUID
		}
		// GetImageById holds details about calls to the GetImageById method.
		GetImageById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetManyImages holds details about calls to the GetManyImages method.
		GetManyImages []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg GetManyImagesParams
		}
		// GetManyUsers holds details about calls to the GetManyUsers method.
		GetManyUsers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg GetManyUsersParams
		}
		// GetUserByEmail holds details about calls to the GetUserByEmail method.
		GetUserByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// GetUserById holds details about calls to the GetUserById method.
		GetUserById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
		// GetUsersCount holds details about calls to the GetUsersCount method.
		GetUsersCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetUsersCountByRole holds details about calls to the GetUsersCountByRole method.
		GetUsersCountByRole []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserRole is the userRole argument value.
			UserRole string
		}
		// HardDeleteUser holds details about calls to the HardDeleteUser method.
		HardDeleteUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
		// InsertOrUpdateImage holds details about calls to the InsertOrUpdateImage method.
		InsertOrUpdateImage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg InsertOrUpdateImageParams
		}
		// InsertOrUpdateRoles holds details about calls to the InsertOrUpdateRoles method.
		InsertOrUpdateRoles []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg InsertOrUpdateRolesParams
		}
		// InsertOrUpdateUser holds details about calls to the InsertOrUpdateUser method.
		InsertOrUpdateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg InsertOrUpdateUserParams
		}
		// SoftDeleteUser holds details about calls to the SoftDeleteUser method.
		SoftDeleteUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uuid.UUID
		}
	}
	lockBeginTx              sync.RWMutex
	lockCheckImageExists     sync.RWMutex
	lockCheckImageHashExists sync.RWMutex
	lockDeleteImage          sync.RWMutex
	lockDeleteRole           sync.RWMutex
	lockGetAllImagesInIDS    sync.RWMutex
	lockGetAllRoles          sync.RWMutex
	lockGetAllUsersInIDS     sync.RWMutex
	lockGetImageById         sync.RWMutex
	lockGetManyImages        sync.RWMutex
	lockGetManyUsers         sync.RWMutex
	lockGetUserByEmail       sync.RWMutex
	lockGetUserById          sync.RWMutex
	lockGetUsersCount        sync.RWMutex
	lockGetUsersCountByRole  sync.RWMutex
	lockHardDeleteUser       sync.RWMutex
	lockInsertOrUpdateImage  sync.RWMutex
	lockInsertOrUpdateRoles  sync.RWMutex
	lockInsertOrUpdateUser   sync.RWMutex
	lockSoftDeleteUser       sync.RWMutex
}

// BeginTx calls BeginTxFunc.
func (mock *DBMock) BeginTx(ctx context.Context, txOpts pgx.TxOptions) (Transactioner, error) {
	if mock.BeginTxFunc == nil {
		panic("DBMock.BeginTxFunc: method is nil but DB.BeginTx was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		TxOpts pgx.TxOptions
	}{
		Ctx:    ctx,
		TxOpts: txOpts,
	}
	mock.lockBeginTx.Lock()
	mock.calls.BeginTx = append(mock.calls.BeginTx, callInfo)
	mock.lockBeginTx.Unlock()
	return mock.BeginTxFunc(ctx, txOpts)
}

// BeginTxCalls gets all the calls that were made to BeginTx.
// Check the length with:
//
//	len(mockedDB.BeginTxCalls())
func (mock *DBMock) BeginTxCalls() []struct {
	Ctx    context.Context
	TxOpts pgx.TxOptions
} {
	var calls []struct {
		Ctx    context.Context
		TxOpts pgx.TxOptions
	}
	mock.lockBeginTx.RLock()
	calls = mock.calls.BeginTx
	mock.lockBeginTx.RUnlock()
	return calls
}

// CheckImageExists calls CheckImageExistsFunc.
func (mock *DBMock) CheckImageExists(ctx context.Context, id uuid.UUID) (bool, error) {
	if mock.CheckImageExistsFunc == nil {
		panic("DBMock.CheckImageExistsFunc: method is nil but DB.CheckImageExists was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockCheckImageExists.Lock()
	mock.calls.CheckImageExists = append(mock.calls.CheckImageExists, callInfo)
	mock.lockCheckImageExists.Unlock()
	return mock.CheckImageExistsFunc(ctx, id)
}

// CheckImageExistsCalls gets all the calls that were made to CheckImageExists.
// Check the length with:
//
//	len(mockedDB.CheckImageExistsCalls())
func (mock *DBMock) CheckImageExistsCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockCheckImageExists.RLock()
	calls = mock.calls.CheckImageExists
	mock.lockCheckImageExists.RUnlock()
	return calls
}

// CheckImageHashExists calls CheckImageHashExistsFunc.
func (mock *DBMock) CheckImageHashExists(ctx context.Context, fileHash []byte) (bool, error) {
	if mock.CheckImageHashExistsFunc == nil {
		panic("DBMock.CheckImageHashExistsFunc: method is nil but DB.CheckImageHashExists was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		FileHash []byte
	}{
		Ctx:      ctx,
		FileHash: fileHash,
	}
	mock.lockCheckImageHashExists.Lock()
	mock.calls.CheckImageHashExists = append(mock.calls.CheckImageHashExists, callInfo)
	mock.lockCheckImageHashExists.Unlock()
	return mock.CheckImageHashExistsFunc(ctx, fileHash)
}

// CheckImageHashExistsCalls gets all the calls that were made to CheckImageHashExists.
// Check the length with:
//
//	len(mockedDB.CheckImageHashExistsCalls())
func (mock *DBMock) CheckImageHashExistsCalls() []struct {
	Ctx      context.Context
	FileHash []byte
} {
	var calls []struct {
		Ctx      context.Context
		FileHash []byte
	}
	mock.lockCheckImageHashExists.RLock()
	calls = mock.calls.CheckImageHashExists
	mock.lockCheckImageHashExists.RUnlock()
	return calls
}

// DeleteImage calls DeleteImageFunc.
func (mock *DBMock) DeleteImage(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteImageFunc == nil {
		panic("DBMock.DeleteImageFunc: method is nil but DB.DeleteImage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteImage.Lock()
	mock.calls.DeleteImage = append(mock.calls.DeleteImage, callInfo)
	mock.lockDeleteImage.Unlock()
	return mock.DeleteImageFunc(ctx, id)
}

// DeleteImageCalls gets all the calls that were made to DeleteImage.
// Check the length with:
//
//	len(mockedDB.DeleteImageCalls())
func (mock *DBMock) DeleteImageCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDeleteImage.RLock()
	calls = mock.calls.DeleteImage
	mock.lockDeleteImage.RUnlock()
	return calls
}

// DeleteRole calls DeleteRoleFunc.
func (mock *DBMock) DeleteRole(ctx context.Context, id string) error {
	if mock.DeleteRoleFunc == nil {
		panic("DBMock.DeleteRoleFunc: method is nil but DB.DeleteRole was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteRole.Lock()
	mock.calls.DeleteRole = append(mock.calls.DeleteRole, callInfo)
	mock.lockDeleteRole.Unlock()
	return mock.DeleteRoleFunc(ctx, id)
}

// DeleteRoleCalls gets all the calls that were made to DeleteRole.
// Check the length with:
//
//	len(mockedDB.DeleteRoleCalls())
func (mock *DBMock) DeleteRoleCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockDeleteRole.RLock()
	calls = mock.calls.DeleteRole
	mock.lockDeleteRole.RUnlock()
	return calls
}

// GetAllImagesInIDS calls GetAllImagesInIDSFunc.
func (mock *DBMock) GetAllImagesInIDS(ctx context.Context, imageIds []uuid.UUID) ([]GetAllImagesInIDSRow, error) {
	if mock.GetAllImagesInIDSFunc == nil {
		panic("DBMock.GetAllImagesInIDSFunc: method is nil but DB.GetAllImagesInIDS was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		ImageIds []uuid.UUID
	}{
		Ctx:      ctx,
		ImageIds: imageIds,
	}
	mock.lockGetAllImagesInIDS.Lock()
	mock.calls.GetAllImagesInIDS = append(mock.calls.GetAllImagesInIDS, callInfo)
	mock.lockGetAllImagesInIDS.Unlock()
	return mock.GetAllImagesInIDSFunc(ctx, imageIds)
}

// GetAllImagesInIDSCalls gets all the calls that were made to GetAllImagesInIDS.
// Check the length with:
//
//	len(mockedDB.GetAllImagesInIDSCalls())
func (mock *DBMock) GetAllImagesInIDSCalls() []struct {
	Ctx      context.Context
	ImageIds []uuid.UUID
} {
	var calls []struct {
		Ctx      context.Context
		ImageIds []uuid.UUID
	}
	mock.lockGetAllImagesInIDS.RLock()
	calls = mock.calls.GetAllImagesInIDS
	mock.lockGetAllImagesInIDS.RUnlock()
	return calls
}

// GetAllRoles calls GetAllRolesFunc.
func (mock *DBMock) GetAllRoles(ctx context.Context) ([]Role, error) {
	if mock.GetAllRolesFunc == nil {
		panic("DBMock.GetAllRolesFunc: method is nil but DB.GetAllRoles was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllRoles.Lock()
	mock.calls.GetAllRoles = append(mock.calls.GetAllRoles, callInfo)
	mock.lockGetAllRoles.Unlock()
	return mock.GetAllRolesFunc(ctx)
}

// GetAllRolesCalls gets all the calls that were made to GetAllRoles.
// Check the length with:
//
//	len(mockedDB.GetAllRolesCalls())
func (mock *DBMock) GetAllRolesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAllRoles.RLock()
	calls = mock.calls.GetAllRoles
	mock.lockGetAllRoles.RUnlock()
	return calls
}

// GetAllUsersInIDS calls GetAllUsersInIDSFunc.
func (mock *DBMock) GetAllUsersInIDS(ctx context.Context, userIds []uuid.UUID) ([]GetAllUsersInIDSRow, error) {
	if mock.GetAllUsersInIDSFunc == nil {
		panic("DBMock.GetAllUsersInIDSFunc: method is nil but DB.GetAllUsersInIDS was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		UserIds []uuid.UUID
	}{
		Ctx:     ctx,
		UserIds: userIds,
	}
	mock.lockGetAllUsersInIDS.Lock()
	mock.calls.GetAllUsersInIDS = append(mock.calls.GetAllUsersInIDS, callInfo)
	mock.lockGetAllUsersInIDS.Unlock()
	return mock.GetAllUsersInIDSFunc(ctx, userIds)
}

// GetAllUsersInIDSCalls gets all the calls that were made to GetAllUsersInIDS.
// Check the length with:
//
//	len(mockedDB.GetAllUsersInIDSCalls())
func (mock *DBMock) GetAllUsersInIDSCalls() []struct {
	Ctx     context.Context
	UserIds []uuid.UUID
} {
	var calls []struct {
		Ctx     context.Context
		UserIds []uuid.UUID
	}
	mock.lockGetAllUsersInIDS.RLock()
	calls = mock.calls.GetAllUsersInIDS
	mock.lockGetAllUsersInIDS.RUnlock()
	return calls
}

// GetImageById calls GetImageByIdFunc.
func (mock *DBMock) GetImageById(ctx context.Context, id uuid.UUID) (Image, error) {
	if mock.GetImageByIdFunc == nil {
		panic("DBMock.GetImageByIdFunc: method is nil but DB.GetImageById was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetImageById.Lock()
	mock.calls.GetImageById = append(mock.calls.GetImageById, callInfo)
	mock.lockGetImageById.Unlock()
	return mock.GetImageByIdFunc(ctx, id)
}

// GetImageByIdCalls gets all the calls that were made to GetImageById.
// Check the length with:
//
//	len(mockedDB.GetImageByIdCalls())
func (mock *DBMock) GetImageByIdCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetImageById.RLock()
	calls = mock.calls.GetImageById
	mock.lockGetImageById.RUnlock()
	return calls
}

// GetManyImages calls GetManyImagesFunc.
func (mock *DBMock) GetManyImages(ctx context.Context, arg GetManyImagesParams) ([]GetManyImagesRow, error) {
	if mock.GetManyImagesFunc == nil {
		panic("DBMock.GetManyImagesFunc: method is nil but DB.GetManyImages was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg GetManyImagesParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockGetManyImages.Lock()
	mock.calls.GetManyImages = append(mock.calls.GetManyImages, callInfo)
	mock.lockGetManyImages.Unlock()
	return mock.GetManyImagesFunc(ctx, arg)
}

// GetManyImagesCalls gets all the calls that were made to GetManyImages.
// Check the length with:
//
//	len(mockedDB.GetManyImagesCalls())
func (mock *DBMock) GetManyImagesCalls() []struct {
	Ctx context.Context
	Arg GetManyImagesParams
} {
	var calls []struct {
		Ctx context.Context
		Arg GetManyImagesParams
	}
	mock.lockGetManyImages.RLock()
	calls = mock.calls.GetManyImages
	mock.lockGetManyImages.RUnlock()
	return calls
}

// GetManyUsers calls GetManyUsersFunc.
func (mock *DBMock) GetManyUsers(ctx context.Context, arg GetManyUsersParams) ([]GetManyUsersRow, error) {
	if mock.GetManyUsersFunc == nil {
		panic("DBMock.GetManyUsersFunc: method is nil but DB.GetManyUsers was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg GetManyUsersParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockGetManyUsers.Lock()
	mock.calls.GetManyUsers = append(mock.calls.GetManyUsers, callInfo)
	mock.lockGetManyUsers.Unlock()
	return mock.GetManyUsersFunc(ctx, arg)
}

// GetManyUsersCalls gets all the calls that were made to GetManyUsers.
// Check the length with:
//
//	len(mockedDB.GetManyUsersCalls())
func (mock *DBMock) GetManyUsersCalls() []struct {
	Ctx context.Context
	Arg GetManyUsersParams
} {
	var calls []struct {
		Ctx context.Context
		Arg GetManyUsersParams
	}
	mock.lockGetManyUsers.RLock()
	calls = mock.calls.GetManyUsers
	mock.lockGetManyUsers.RUnlock()
	return calls
}

// GetUserByEmail calls GetUserByEmailFunc.
func (mock *DBMock) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	if mock.GetUserByEmailFunc == nil {
		panic("DBMock.GetUserByEmailFunc: method is nil but DB.GetUserByEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockGetUserByEmail.Lock()
	mock.calls.GetUserByEmail = append(mock.calls.GetUserByEmail, callInfo)
	mock.lockGetUserByEmail.Unlock()
	return mock.GetUserByEmailFunc(ctx, email)
}

// GetUserByEmailCalls gets all the calls that were made to GetUserByEmail.
// Check the length with:
//
//	len(mockedDB.GetUserByEmailCalls())
func (mock *DBMock) GetUserByEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockGetUserByEmail.RLock()
	calls = mock.calls.GetUserByEmail
	mock.lockGetUserByEmail.RUnlock()
	return calls
}

// GetUserById calls GetUserByIdFunc.
func (mock *DBMock) GetUserById(ctx context.Context, userID uuid.UUID) (GetUserByIdRow, error) {
	if mock.GetUserByIdFunc == nil {
		panic("DBMock.GetUserByIdFunc: method is nil but DB.GetUserById was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockGetUserById.Lock()
	mock.calls.GetUserById = append(mock.calls.GetUserById, callInfo)
	mock.lockGetUserById.Unlock()
	return mock.GetUserByIdFunc(ctx, userID)
}

// GetUserByIdCalls gets all the calls that were made to GetUserById.
// Check the length with:
//
//	len(mockedDB.GetUserByIdCalls())
func (mock *DBMock) GetUserByIdCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockGetUserById.RLock()
	calls = mock.calls.GetUserById
	mock.lockGetUserById.RUnlock()
	return calls
}

// GetUsersCount calls GetUsersCountFunc.
func (mock *DBMock) GetUsersCount(ctx context.Context) (int64, error) {
	if mock.GetUsersCountFunc == nil {
		panic("DBMock.GetUsersCountFunc: method is nil but DB.GetUsersCount was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetUsersCount.Lock()
	mock.calls.GetUsersCount = append(mock.calls.GetUsersCount, callInfo)
	mock.lockGetUsersCount.Unlock()
	return mock.GetUsersCountFunc(ctx)
}

// GetUsersCountCalls gets all the calls that were made to GetUsersCount.
// Check the length with:
//
//	len(mockedDB.GetUsersCountCalls())
func (mock *DBMock) GetUsersCountCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetUsersCount.RLock()
	calls = mock.calls.GetUsersCount
	mock.lockGetUsersCount.RUnlock()
	return calls
}

// GetUsersCountByRole calls GetUsersCountByRoleFunc.
func (mock *DBMock) GetUsersCountByRole(ctx context.Context, userRole string) (int64, error) {
	if mock.GetUsersCountByRoleFunc == nil {
		panic("DBMock.GetUsersCountByRoleFunc: method is nil but DB.GetUsersCountByRole was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		UserRole string
	}{
		Ctx:      ctx,
		UserRole: userRole,
	}
	mock.lockGetUsersCountByRole.Lock()
	mock.calls.GetUsersCountByRole = append(mock.calls.GetUsersCountByRole, callInfo)
	mock.lockGetUsersCountByRole.Unlock()
	return mock.GetUsersCountByRoleFunc(ctx, userRole)
}

// GetUsersCountByRoleCalls gets all the calls that were made to GetUsersCountByRole.
// Check the length with:
//
//	len(mockedDB.GetUsersCountByRoleCalls())
func (mock *DBMock) GetUsersCountByRoleCalls() []struct {
	Ctx      context.Context
	UserRole string
} {
	var calls []struct {
		Ctx      context.Context
		UserRole string
	}
	mock.lockGetUsersCountByRole.RLock()
	calls = mock.calls.GetUsersCountByRole
	mock.lockGetUsersCountByRole.RUnlock()
	return calls
}

// HardDeleteUser calls HardDeleteUserFunc.
func (mock *DBMock) HardDeleteUser(ctx context.Context, userID uuid.UUID) error {
	if mock.HardDeleteUserFunc == nil {
		panic("DBMock.HardDeleteUserFunc: method is nil but DB.HardDeleteUser was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockHardDeleteUser.Lock()
	mock.calls.HardDeleteUser = append(mock.calls.HardDeleteUser, callInfo)
	mock.lockHardDeleteUser.Unlock()
	return mock.HardDeleteUserFunc(ctx, userID)
}

// HardDeleteUserCalls gets all the calls that were made to HardDeleteUser.
// Check the length with:
//
//	len(mockedDB.HardDeleteUserCalls())
func (mock *DBMock) HardDeleteUserCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockHardDeleteUser.RLock()
	calls = mock.calls.HardDeleteUser
	mock.lockHardDeleteUser.RUnlock()
	return calls
}

// InsertOrUpdateImage calls InsertOrUpdateImageFunc.
func (mock *DBMock) InsertOrUpdateImage(ctx context.Context, arg InsertOrUpdateImageParams) error {
	if mock.InsertOrUpdateImageFunc == nil {
		panic("DBMock.InsertOrUpdateImageFunc: method is nil but DB.InsertOrUpdateImage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg InsertOrUpdateImageParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertOrUpdateImage.Lock()
	mock.calls.InsertOrUpdateImage = append(mock.calls.InsertOrUpdateImage, callInfo)
	mock.lockInsertOrUpdateImage.Unlock()
	return mock.InsertOrUpdateImageFunc(ctx, arg)
}

// InsertOrUpdateImageCalls gets all the calls that were made to InsertOrUpdateImage.
// Check the length with:
//
//	len(mockedDB.InsertOrUpdateImageCalls())
func (mock *DBMock) InsertOrUpdateImageCalls() []struct {
	Ctx context.Context
	Arg InsertOrUpdateImageParams
} {
	var calls []struct {
		Ctx context.Context
		Arg InsertOrUpdateImageParams
	}
	mock.lockInsertOrUpdateImage.RLock()
	calls = mock.calls.InsertOrUpdateImage
	mock.lockInsertOrUpdateImage.RUnlock()
	return calls
}

// InsertOrUpdateRoles calls InsertOrUpdateRolesFunc.
func (mock *DBMock) InsertOrUpdateRoles(ctx context.Context, arg InsertOrUpdateRolesParams) error {
	if mock.InsertOrUpdateRolesFunc == nil {
		panic("DBMock.InsertOrUpdateRolesFunc: method is nil but DB.InsertOrUpdateRoles was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg InsertOrUpdateRolesParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertOrUpdateRoles.Lock()
	mock.calls.InsertOrUpdateRoles = append(mock.calls.InsertOrUpdateRoles, callInfo)
	mock.lockInsertOrUpdateRoles.Unlock()
	return mock.InsertOrUpdateRolesFunc(ctx, arg)
}

// InsertOrUpdateRolesCalls gets all the calls that were made to InsertOrUpdateRoles.
// Check the length with:
//
//	len(mockedDB.InsertOrUpdateRolesCalls())
func (mock *DBMock) InsertOrUpdateRolesCalls() []struct {
	Ctx context.Context
	Arg InsertOrUpdateRolesParams
} {
	var calls []struct {
		Ctx context.Context
		Arg InsertOrUpdateRolesParams
	}
	mock.lockInsertOrUpdateRoles.RLock()
	calls = mock.calls.InsertOrUpdateRoles
	mock.lockInsertOrUpdateRoles.RUnlock()
	return calls
}

// InsertOrUpdateUser calls InsertOrUpdateUserFunc.
func (mock *DBMock) InsertOrUpdateUser(ctx context.Context, arg InsertOrUpdateUserParams) error {
	if mock.InsertOrUpdateUserFunc == nil {
		panic("DBMock.InsertOrUpdateUserFunc: method is nil but DB.InsertOrUpdateUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg InsertOrUpdateUserParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertOrUpdateUser.Lock()
	mock.calls.InsertOrUpdateUser = append(mock.calls.InsertOrUpdateUser, callInfo)
	mock.lockInsertOrUpdateUser.Unlock()
	return mock.InsertOrUpdateUserFunc(ctx, arg)
}

// InsertOrUpdateUserCalls gets all the calls that were made to InsertOrUpdateUser.
// Check the length with:
//
//	len(mockedDB.InsertOrUpdateUserCalls())
func (mock *DBMock) InsertOrUpdateUserCalls() []struct {
	Ctx context.Context
	Arg InsertOrUpdateUserParams
} {
	var calls []struct {
		Ctx context.Context
		Arg InsertOrUpdateUserParams
	}
	mock.lockInsertOrUpdateUser.RLock()
	calls = mock.calls.InsertOrUpdateUser
	mock.lockInsertOrUpdateUser.RUnlock()
	return calls
}

// SoftDeleteUser calls SoftDeleteUserFunc.
func (mock *DBMock) SoftDeleteUser(ctx context.Context, userID uuid.UUID) error {
	if mock.SoftDeleteUserFunc == nil {
		panic("DBMock.SoftDeleteUserFunc: method is nil but DB.SoftDeleteUser was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uuid.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockSoftDeleteUser.Lock()
	mock.calls.SoftDeleteUser = append(mock.calls.SoftDeleteUser, callInfo)
	mock.lockSoftDeleteUser.Unlock()
	return mock.SoftDeleteUserFunc(ctx, userID)
}

// SoftDeleteUserCalls gets all the calls that were made to SoftDeleteUser.
// Check the length with:
//
//	len(mockedDB.SoftDeleteUserCalls())
func (mock *DBMock) SoftDeleteUserCalls() []struct {
	Ctx    context.Context
	UserID uuid.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID uuid.UUID
	}
	mock.lockSoftDeleteUser.RLock()
	calls = mock.calls.SoftDeleteUser
	mock.lockSoftDeleteUser.RUnlock()
	return calls
}
